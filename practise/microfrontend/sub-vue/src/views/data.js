const resp = {
  "success": true,
  "data": [
    {
      "id": "6100f54de3e67140e158fe63",
      "author_id": "4efc278625fa69ac6900038f",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>活动介绍</h2>\n<p>活动官方网站：<a href=\"https://subway.midwayjs.org/\">https://subway.midwayjs.org/</a>\n第十二届 Node 地下铁将于 2021 年 8 月 8 日在北京线下举行，我们邀请了业界 4 位有实践和落地经验的同学给大家分享相关话题，欢迎各位报名。</p>\n<p>PC 报名地址：<a href=\"https://www.huodongxing.com/event/6608502975800\">https://www.huodongxing.com/event/6608502975800</a></p>\n<h2>时间地点</h2>\n<p>沙龙时间：2021 年 8 月 8 日（周日）\n沙龙地点：北京·融新科技中心B座（创远路34号院5号楼）\n面向人群：Node.js 开发者</p>\n<h2>日程安排</h2>\n<p>13：00-13：30   活动签到\n13：30-13：40   开场\n13：40-14：20   杜佳昆：《云原生时代的 Alinode》\n14：20-15：00   李洋洋：《Node.js / NestJS 在 Authing 架构中的演进和工程实践》\n15：00-15：10   间休\n15：10-15：50   王东：《基于 Node.js 的物联网平台应用层实践》\n15：50-16：30   贾建容：《高德 Node.js Serverless体系化建设之路》\n16：30-16：35   北京 Node.js 圆桌讨论 + 抽奖\n17：00   合照 &amp; 结束</p>\n<h2>活动海报</h2>\n<p><img src=\"//static.cnodejs.org/FqcUo5fO-xn3tjHs4KUdOjYfkzkH\" alt=\"第十二届地下铁海报.jpg\"></p>\n<h2>温馨提示</h2>\n<p>1、本次活动免费。\n2、报名的朋友们如果提供的email和手机号码无误，我们会在活动开始前一天发送短信和邮件确认。所以请确认自己填写的email地址无误。\n3、本活动欢迎大家带自己的同事和朋友一起参加，不过为了确保良好的听课环境，请尽可能提前为他们报名。</p>\n</div>",
      "title": "2021年8 月8 日 第十二届 Node 地下铁北京专场来啦，开启报名中",
      "last_reply_at": "2021-08-02T03:55:51.564Z",
      "good": false,
      "top": true,
      "reply_count": 7,
      "visit_count": 1213,
      "create_at": "2021-07-28T06:12:29.276Z",
      "author": {
        "loginname": "czy88840616",
        "avatar_url": "//gravatar.com/avatar/c4e414b7264b513a00bbd8ec3e9a0d66?s=48"
      }
    },
    {
      "id": "601e668a03d797cf5b66f437",
      "author_id": "54009f5ccd66f2eb37190485",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>PPT地址</h2>\n<p><a href=\"https://github.com/midwayjs/subway-station/tree/master/No.10.HangZhou.Let%E2%80%99s%20imagine%202021\">https://github.com/midwayjs/subway-station/tree/master/No.10.HangZhou.Let’s imagine 2021</a>!</p>\n<h2>喜欢的自取</h2>\n<p>本次采用线上直播方式，会使用阿里的会议室，此次Node Party使用Node地下铁品牌。会在视频号：AlibabaF2E和Bilibili：支付宝体验科技同时直播。</p>\n<p>大家有啥想法可以随时补充。</p>\n<h2>主题分享</h2>\n<h3>1、《基于 Addon 的 Node.js 性能监控与线上故障定位解决方案》</h3>\n<p>选题理由：<strong>如果说2020国内Node.js社区最大的事件，我以为是 Easy-Monitor 3.0 版本开源了，它是一款Node.js 应用性能监控与线上故障定位解决方案。</strong></p>\n<p>Topic简介：旨在 Node.js 的开源生态工具链上，做一些能帮助到想使用和正在使用 Node.js 的开发者更好地感知自己的 Node.js 应用状态，以更好地面对来自性能和稳定性方面的挑战。</p>\n<p>个人简介：<a href=\"https://github.com/hyj1991/\">hyj1991</a>，开源 Node.js 性能监控工具 <a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a> 作者，参与了开源框架 Egg.js 的维护，以前 AliNode 的核心开发者之一，前端架构师，目前在社区一直致力于 Node.js 基础保障性质工具链的进一步完善。</p>\n<p><img src=\"//static.cnodejs.org/Fkm3ogNc8lbsjFMQatCF54qgyUul\" alt=\"16126047795218.jpg\"></p>\n<h3>2、《Midway Hooks — 更具生产力的全栈框架：全栈、“零” API、Hooks 开发后端》</h3>\n<p>选题理由：<strong>Midway Hooks是社区Web方向比较有新意的项目，面向FaaS让开发更简单，面向React开发者，让同构全栈更简单。</strong></p>\n<p>简介：<a href=\"https://github.com/midwayjs/hooks\">Midway Hooks</a> 是为前端开发者打造的全栈框架，具有以下优势：☁️ 全栈，在 src 目录中开发前后端代码、🌈 “零”API，极其简单的后端 Api 开发与调用方式、🌍 使用 “React Hooks” 开发后端。本次分享则将为大家介绍 Midway Hooks 的用法、设计理念以及背后的技术原理。</p>\n<p>个人简介：刘子健（花名繁易，Lxxyx：Node.js），淘系技术部-前端架构团队成员。开源爱好者，Node.js Core Collaborator，目前致力于打造更具生产力的全栈框架：Midway Hooks。</p>\n<p><img src=\"//static.cnodejs.org/FsqpQzPYFIz0xzXGGIwf5CxjFSML\" alt=\"16126048815842.jpg\"></p>\n<h3>3、《比Webpack5快4倍的AirpackCDN — 新一代组件分发网络构建之路》</h3>\n<p>选题理由：<strong>Deno带动了http import的发展，同时也使得社区从Commonjs到ESM的趋势日渐明显，这就促使社区会出现新一代CDN技术的诞生。</strong></p>\n<p>Topic简介：AirpackCDN 是适用于现代 Web 应用程序的组件分发网络 (Components Delivery Network for modern web apps)，是集团内第一个为现代 JavaScript 应用程序设计和优化的 CDN（注：还未开源，筹备中）。通过 Airpack 网络的分发的组件可以直接在浏览器中使用，且针对浏览器做了大量优化，几乎所有软件包都可以以 ES Module 的格式对外输出，我们致力于构建一个可以依赖的核心基础设施。</p>\n<p>作者简介：赵吉彤（花名：牧曈），阿里云体验技术团队前端工程师，主攻前端中后台、工程化方向，开源爱好者，资深极客。</p>\n<p><img src=\"//static.cnodejs.org/FjDKce673wxx97YeqhT62wpx94oO\" alt=\"16125037643179.jpg\"></p>\n<h3>4、《iMove—致力于提高开发效率的js框架：开启可视化编排的新型开发模式》</h3>\n<p>选题理由：<strong>前端智能化解决了设计稿到代码的UI渲染部分，但逻辑代码如何生成依然是一个难题。iMove算一个不错的探索</strong></p>\n<p>Topic简介：<a href=\"https://github.com/imgcook/imove\">iMove</a>是为开发者打造的支持可视化编排的js框架，具有以下优势：🔥逻辑可组装：接口和UI在最小粒度上的复用；☁️流程可视化：最小单元通过流程图进行编排；🌈 逻辑复用：将逻辑进行沉淀，变成可复用的能力；🌲运营配置收敛：降低运营操作成本。本次分享则将为大家介绍 iMove 的使用方法、底层原理、设计思想，以及此框架是如何解决低代码开发中的痛点问题的。</p>\n<p>个人简介：杨佩（花名冷卉），阿里淘系技术部f(x) team团队成员，iMove核心成员，开源爱好者。目前致力于打造用于提高开发效率的新一代智能化基建。</p>\n<p><img src=\"//static.cnodejs.org/FjXLoj0EpAmLhgACJK5Sw5OuJUMD\" alt=\"16126049650090.jpg\"></p>\n<h3>5、《SSR framework 2.0 -同时支持React, Vue 的服务端渲染能力》</h3>\n<p>选题理由：<strong>从egg-react-ssr到ykfe/ssr是一个不错的演进，Serverless-side render概念也慢慢被大家接受，2020年淘宝双十一使用了ssr，拼多多的页面渲染也使用了ssr，可见ssr是一个不可缺少的Web应用技术。</strong></p>\n<p>Topic简介：<a href=\"https://github.com/ykfe/ssr\">SSR framework 2.0</a>集成自ykfe/ssr 1.0，同时支持React, Vue 的服务端渲染能力，以插件化的形式支持任意服务端框架与前端框架的结合，同时支持Serverless方式或传统Node.js应用方式部署.</p>\n<p>个人简介：张宇昂，微信前端工程师，前阿里巴巴前端工程师，专注于 Node.js 与前端的结合在企业的实践落地，ykfe/ssr框架核心开发者, 下一代前端构建工具Vite爱好者和Rust 爱好者。</p>\n<p><img src=\"//static.cnodejs.org/FjnIQLlOsfUyoaFmt7_vbWrVWVmi\" alt=\"image.png\"></p>\n<h2>大佬圆桌会</h2>\n<p>待定：本次线下在杭州，大果、流司、雷姆、死月</p>\n<p>还没有沟通完成</p>\n<h2>直播信息</h2>\n<ul>\n<li>时间：2021年3月6日，下午2点-6点</li>\n<li>Obs推流</li>\n</ul>\n<h3>1）微信视频号：AlibabaF2E</h3>\n<p><img src=\"//static.cnodejs.org/FtM_sWKCWUbmiXTx36xP0dv50n7E\" alt=\"image.png\"></p>\n<h3>2）Bilibili：支付宝体验科技</h3>\n<p><img src=\"//static.cnodejs.org/FnaquwPttUJx7haOT51yjR8kekzP\" alt=\"image.png\"></p>\n<h2>活动安排</h2>\n<p>稍后给出</p>\n<h2>沟通群</h2>\n<p>如果想参加活动，反馈意见都可以加入下面这个钉钉群</p>\n<p><img src=\"//static.cnodejs.org/Ft0nBD73FkFw8CBbceGjo0HW29iu\" alt=\"image.png\"></p>\n</div>",
      "title": "2021年3月6日Node Party PPT",
      "last_reply_at": "2021-08-01T09:03:41.916Z",
      "good": false,
      "top": true,
      "reply_count": 31,
      "visit_count": 80004,
      "create_at": "2021-02-06T09:51:06.662Z",
      "author": {
        "loginname": "i5ting",
        "avatar_url": "https://avatars.githubusercontent.com/u/3118295?v=4&s=120"
      }
    },
    {
      "id": "5fdb44d70f99cb37f45e3410",
      "author_id": "56f3686f02c237a73a1a8acf",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>RT.</p>\n<p>请大家遵守法律法规，勿发布不合规内容。</p>\n</div>",
      "title": "请大家遵纪守法，勿发布不合规内容",
      "last_reply_at": "2021-07-30T05:18:11.576Z",
      "good": false,
      "top": true,
      "reply_count": 159,
      "visit_count": 78798,
      "create_at": "2020-12-17T11:45:27.667Z",
      "author": {
        "loginname": "thonatos",
        "avatar_url": "https://avatars.githubusercontent.com/u/958063?v=4&s=120"
      }
    },
    {
      "id": "607ea4374d20cbe2d168d737",
      "author_id": "515005e9604b3d512109bb17",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>五月是一个好月份，五月的武汉也很漂亮。2020 年，疫情肆虐，我们无奈停止了 Node 地下铁一段时间。今年 3 月份我们重启了 Node 地下铁；而今年五月，我们决定与大家一起去见证一下武汉焕新的活力，在武汉举办一场热干面专场（第 11 期）。</p>\n<p>Node 地下铁沙龙是阿里巴巴淘系前端发起的一个线下技术沙龙。非常感谢有赞联合举办本期活动。</p>\n<h2>活动信息</h2>\n<ul>\n<li><strong>本期主题</strong>：从社区到企业级实践</li>\n<li><strong>本期出品人</strong>：死月；</li>\n<li><strong>主持人</strong>：艺璇；</li>\n<li><strong>圆桌主持人</strong>：狼叔（i5ting）；</li>\n<li><strong>时间</strong>：2021 年 5 月 23 日 13:00 ~ 18:00；</li>\n<li><strong>地点</strong>：武汉保利国际中心 35 层 P1-2。</li>\n</ul>\n<p>本期我们邀请到了淘宝、蚂蚁集团、有赞、腾讯以及 Wiredcraft 的小伙伴，为大家献上新的一期 Node.js 话题盛宴，炒一炒武汉这个美丽城市的 Node.js 热度。活动最后，还有神秘嘉宾**狼叔（i5ting）**为大家主持圆桌讨论和抽奖。真的血赚！</p>\n<p>感兴趣的小伙伴们，无论你们是已经在职工作，还是尚在学校进修，都欢迎来报名呀。Node 地下铁报名免费，只要通过审核即可来参加。**名额有限，先到先得。**望大家互相传阅。</p>\n<blockquote>\n<p>本期官网：<a href=\"https://subway.midwayjs.org/\">https://subway.midwayjs.org/</a></p>\n<p>报名链接：<a href=\"https://www.huodongxing.com/event/7596833409300\">https://www.huodongxing.com/event/7596833409300</a></p>\n</blockquote>\n<h2>话题介绍</h2>\n<h3>Node.js 在 TARS 微服务框架中的实践</h3>\n<p><img src=\"//static.cnodejs.org/FnSk20oDl0RaRhRupa-2jCqK-9Fo\" alt=\"image.png\"></p>\n<blockquote>\n<p>邹成卓 @腾讯 高级前端工程师</p>\n</blockquote>\n<p>TARS Node.js 是开源微服务框架 TARS 的 Node.js 语言部分，为 Node.js 服务端提供了一套完整的开发运维环境。包含了进程管理、日志输出、调用监控、特性监控、RPC 调用、快速扩缩容等功能，让 Node.js 开发者可以专注于业务代码，其它交给 TARS。</p>\n<h3>Node.js &amp; Midway.js 源码贡献指北</h3>\n<p><img src=\"//static.cnodejs.org/FnIqqd_BtjPowS1mxBioW6Eck9K5\" alt=\"image.png\"></p>\n<blockquote>\n<p>刘子健 @淘宝 / Node.js Core Collaborator</p>\n</blockquote>\n<p>开源生态是现代软件开发中极其重要的组成部分，以 Node.js 为例，自发布以来持续有社区的开发者为其贡献代码。本次分享也将从 Node.js 源码出发，讲解其源码构成与贡献方式。同时我们也会讲解阿里巴巴的开源 Node.js 框架 Midway 开发方式，帮助新手更快的投入的社区开源项目的建设中。</p>\n<h3>复杂系统的原理及其在 Node.js 系统开发中的应用</h3>\n<p><img src=\"//static.cnodejs.org/Frz8neRk38efUCCpIwRc5G_wB86b\" alt=\"image.png\"></p>\n<blockquote>\n<p>王韬 <a href=\"/user/Wiredcraft\">@Wiredcraft</a> 架构师</p>\n</blockquote>\n<p>在软件行业，大量系统架构设计和工作流程设计还是基于经验或直觉，特定环境中特定决策的后果难以预测，团队成员的决策能力难以高效提升，我们需要用更加工程化的方式，做出高质量的决策。本次分享介绍一些复杂系统领域的基本原理，以及在使用 Node.js 进行开发中的应用。</p>\n<h3>App Engine——一个轻量级的 Node.js 服务托管和调度平台</h3>\n<p><img src=\"//static.cnodejs.org/Fly7yNP2ISvn4dw_XlGXZjco36Xk\" alt=\"image.png\"></p>\n<blockquote>\n<p>王干（KK） @有赞 技术专家</p>\n</blockquote>\n<p>有赞 App Engine（应用引擎）是一套面向前端开发及运维的一站式 Node.js 服务容器化平台，为前端开发者提供统一和规范化的 Node.js 服务研发模式。本次分享将为大家介绍有赞 App Engine 的设计理念、实践总结以及背后的技术原理。</p>\n<h3>JavaScript 全栈高效研发在语雀中的实践</h3>\n<p><img src=\"//static.cnodejs.org/FtCsHoEri9rSIVXYYEMy8mUmRZoT\" alt=\"image.png\"></p>\n<blockquote>\n<p>赵珊珊（西临） @蚂蚁集团 前端专家</p>\n</blockquote>\n<p>语雀作为一个复杂的 Node.js 应用，如何以小规模的研发团队支撑业务的快速发展是我们不断探索的命题。这几年，我们在业务实践中总结出了一些能够有效保障研发效率的全栈开发经验，本次分享将为大家一一介绍。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i3/O1CN01ayQ7Wh1SOafw66J2N_!!6000000002237-0-tps-750-2273.jpg\" alt></p>\n</div>",
      "title": "5 月 23 日Node 地下铁武汉热干面专场PPT",
      "last_reply_at": "2021-07-20T13:41:23.521Z",
      "good": false,
      "top": true,
      "reply_count": 78,
      "visit_count": 74234,
      "create_at": "2021-04-20T09:51:51.711Z",
      "author": {
        "loginname": "XadillaX",
        "avatar_url": "https://avatars.githubusercontent.com/u/2842176?v=4&s=120"
      }
    },
    {
      "id": "60cc47ff248d044ba14add37",
      "author_id": "5d47c83b4f472f7fee152927",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://codepen.io/\">codepen</a> 可以说是非常实用了<br>\n但由于网络原因，很多用户访问不到，或者非常慢<br>\n另外，如果你的代码很简单，用 codepen 显得有点不够简洁</p>\n<p><a href=\"https://dagaiguanyu.github.io/showcode/index.html?html=%25u8FD9%25u91CC%25u5199%20html%20%25u4EE3%25u7801&amp;css=/*%20%25u8FD9%25u91CC%25u5199%20css%20%25u4EE3%25u7801%20*/&amp;js=console.log%28%27%25u8FD9%25u91CC%25u5199%20js%20%25u4EE3%25u7801%27%29\">今天，出于好玩，写了个简陋版的 codepen，欢迎大家来看看</a><br>\n只支持 html、css、js 代码，但支持分享代码（永久有效，github 不倒闭，我不倒闭）<br>\n(不支持 ts、sass、stylus 等需要编译的语言，也没有打开就能用的 vue、react 环境，毕竟在没有任何依赖的情况下，前后端总共只使用了不到 200 行代码）</p>\n</div>",
      "title": "今天写了个极简版的 codepen",
      "last_reply_at": "2021-08-02T17:02:55.728Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 1577,
      "create_at": "2021-06-18T07:15:11.739Z",
      "author": {
        "loginname": "daGaiGuanYu",
        "avatar_url": "https://avatars.githubusercontent.com/u/27003009?v=4&s=120"
      }
    },
    {
      "id": "596eb7768f05de0819fdb301",
      "author_id": "538ebff9c3ee0b58208376c7",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>如题。知道内情的进来说说？<a href=\"/user/alsotang\">@alsotang</a> and <a href=\"/user/i5ting\">@i5ting</a>？</p>\n</div>",
      "title": "听说明年2月之前要禁止所有个人用户使用VPN，是真的吗？",
      "last_reply_at": "2021-08-02T16:57:35.284Z",
      "good": false,
      "top": false,
      "reply_count": 55,
      "visit_count": 16074,
      "create_at": "2017-07-19T01:35:50.929Z",
      "author": {
        "loginname": "zhanzhenzhen",
        "avatar_url": "https://avatars3.githubusercontent.com/u/731796?v=4&s=120"
      }
    },
    {
      "id": "60e503bfba7460b2a0862a7e",
      "author_id": "60e50164ba74605814862a73",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>话不多说，先放上截图和仓库地址：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4319bf92bf64975872cc34c25078cec~tplv-k3u1fbpfcp-watermark.image\" alt=\"QQ20210705-210753.gif\"></p>\n<p>代码仓库：<a href=\"https://github.com/clouDr-f2e/rubick\">github</a></p>\n<h2>故事背景</h2>\n<h3>网络抓包</h3>\n<p>之前公司内部因为开发需要，需要和后端进行接口联调，测试环境的时候，经常会涉及到一些状态改变要看交互样式的问题。比如测试需要测商品的待支付、支付中、支付完成等各种节点的交互样式是否符合预期，这种情况测试一般会去造数据或者让后端改数据库接口。\n有的小伙伴可能会用<code>Charles</code>修改返回数据进行测试。但是<code>Charles</code>的抓包体验和配置体验感觉有点麻烦，不是很友好，所以我们自己做了个<code>抓包&amp;mock</code>工具：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe19cfe19ff4fb099202c7a87addc7f~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>傻瓜式交互一次性解决：抓包、代理、请求转发、接口数据篡改mock、跨域访问 等能力，并得到了广泛使用和好评。</p>\n<h3>文件上传</h3>\n<p>随着项目开发的继续，有些用户给我们反馈页面加载图片资源比较慢，我们看了一下很多图片资源都没有经过压缩处理，这个时候我们可以通过 <code>webpack</code> 写了一些 <code>loader</code> 来对图片资源进行压缩处理。这个时候我们的图片资源大部分是存放在项目目录下。而有的时候，我们是需要将图片存放于 <code>cdn</code> 上的，此时我们又需要一个图床工具，可以在线存储图片资源。于是乎，我们又整合了图片压缩和上传的功能，做了个图床工具：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/542fcabe595740e19665e8f07edb3e99~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>性能测评</h3>\n<p>开发者开发页面的时候，需要对页面的性能进行评估，另一方面也可以把评估报告通知给测试同学，对其进行性能测试。之前大多采用的是 <code>chrome</code> 插件 <code>lighthouse</code> 来做。但是这个东西对未登录用户无法做到性能评估，因为用户未登录直接测评了登录页面，显然不符合预期，其次，每个电脑上都得安装插件，受限于设备的不同，可能会导致性能没有同一的变量（网络、网速、分辨率、CUP等）。所以我们基于 <code>pupeeteer-core</code>以及<code>electron</code> 做了一个免登的测评工具：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2ce2d6baad343e49a2b589f1fc9f63a~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>但是这些还远远不够，我们随着业务的增加，功能愈发的多了起来：我们的埋点检测工具、需求管理工具、前端多环境切换工具 等等等…一方面导致 <code>electron</code> 体积变得臃肿起来，另一方面随着发布频率增加，安装下载的成本也越来越大，很多用户就不愿意再接着安装，因为确实很麻烦。所以我们需要改变，让功能不依赖与容器。这就需要把我们的功能全部独立出去，做成<strong>插件化</strong>。所以我注意到了 <a href=\"https://u.tools/\">utools</a></p>\n<h2>插件化之旅</h2>\n<p>一开始想到做插件化，无非就是使用 <code>electron</code> 的 <code>webview</code> 能力，实现类似于原生内嵌<code>h5</code>那样的方式，<code>h5</code> 页面可以做独立发布，原生提供 <code>nativaAPI</code> 之间通过 <code>jsBridge</code> 来桥接调用原生的方法。这样实现并无问题，我们也尝试了做了一次。最终思路大概是：</p>\n<h3>electron webview 方式</h3>\n<h4>1. electron 中使用 webview</h4>\n<pre class=\"prettyprint language-html\"><code>&lt;webview src=&quot;https:&#x2F;&#x2F;xxx.xx.com&#x2F;index.html&quot; preload=&quot;preload.js&quot; &#x2F;&gt;\n</code></pre><h4>2. 实现 <code>bridge</code></h4>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; preload.js\nwindow.rubickBridge = {\n  sayHello() {\n    console.log(&#x27;hello world&#x27;)\n  }\n}\n</code></pre><h4>3. 插件借助 <code>bridge</code> 调用 <code>electron</code> 的能力</h4>\n<pre class=\"prettyprint language-html\"><code>&lt;html&gt;\n &lt;body&gt;\n     &lt;div&gt;这是一个插件&lt;div&gt;\n &lt;&#x2F;body&gt;\n &lt;script&gt;\n  window.rubickBridge.sayHello()\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h4>4. 通信</h4>\n<p>因为 <code>proload.js</code> 是 <code>electron</code> 的 <code>renderer</code> 进程的，所以如果需要使用部分 <code>main</code> 进程的能力，则需要使用通信机制：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; main process\nipcMain.on(&#x27;msg-trigger&#x27;, async (event, arg) =&gt; {\n    const window = arg.winId ? BrowserWindow.fromId(arg.winId) : mainWindow\n    const operators = arg.type.split(&#x27;.&#x27;);\n    let fn = Api;\n    operators.forEach((op) =&gt; {\n      fn = fn[op];\n    });\n    const data = await fn(arg, window);\n    event.sender.send(&#96;msg-back-${arg.type}&#96;, data);\n});\n  \n&#x2F;&#x2F; renderer process\nipcRenderer.send(&#x27;msg-trigger&#x27;, {\n  type: &#x27;getPath&#x27;,\n  name,\n});\nipcRenderer.on(&#96;msg-back-getPath&#96;, (e, result) =&gt; {\n  console.log(result)\n});\n</code></pre><h3>为什么后来我们又放弃了这条路🤔 ？</h3>\n<p>其实上面的思路大致是没啥问题的，我们也基于上面的思路成功把功能抽成了插件，按照插件的方式进行安装加载。直到我们注意到 <code>utools</code> 的强大，感觉 <code>utools</code> 的生态非常丰富，我们要是能集成 <code>utools</code> 的生成那该多好呀！所以我们秉持着干不过他就成为他的原则，我们尝试着成为他。但是 <code>utools</code> 本身并没有开源，所以没有办法去吸取一些优秀的代码实现，但是我们可以看他的官方文档。</p>\n<p>我们发现其实 <code>utools</code> 大多数插件都是和 <code>container</code> 层分离的，也就是说 <code>utools</code> 只是一个插件的容器，为插件提供了一些 <code>api</code> 能力和方法。所以一旦我们实现了<code>utools</code>加载插件的能力，实现 <code>utools</code> 的所有 <code>API</code> 函数，是不是就约等于实现了 <code>utools</code> ! 我们就可以使用 <code>utools</code> 的插件？</p>\n<h3>utools 方式</h3>\n<p>按照 utools 的 文档，首先我们需要实现一个插件，必须要有个 <code>plugin.json</code>，这玩意就是用来告诉 <code>utools</code> 插件的信息。我们也按照文档来写：</p>\n<pre class=\"prettyprint language-json\"><code>{\n    &quot;pluginName&quot;: &quot;helloWorld&quot;,\n    &quot;description&quot;: &quot;我的第一个uTools插件&quot;,\n    &quot;main&quot;: &quot;index.html&quot;,\n    &quot;version&quot;: &quot;0.0.1&quot;,\n    &quot;logo&quot;: &quot;logo.png&quot;,\n    &quot;features&quot;: [\n        {\n          &quot;code&quot;: &quot;hello&quot;,\n          &quot;explain&quot;: &quot;hello world&quot;,\n          &quot;cmds&quot;:[&quot;hello&quot;, &quot;你好&quot;]\n        }\n    ]\n}\n</code></pre><p>接下来是将写好的插件用 <code>utools</code> 跑起来，按照 <code>utools</code>的交互是复制 <code>plugin.json</code> 到<code>utools</code>搜索框即可，我们也可以实现：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 监听 input change\n&#x2F;&#x2F; 读取剪切板内容\nconst fileUrl = clipboard.read(&#x27;public.file-url&#x27;).replace(&#x27;file:&#x2F;&#x2F;&#x27;, &#x27;&#x27;);\n&#x2F;&#x2F; 复制文件\nif (fileUrl &amp;&amp; value === &#x27;plugin.json&#x27;) {\n  &#x2F;&#x2F; 读取 plugin.json 配置\n  const config = JSON.parse(fs.readFileSync(fileUrl, &#x27;utf-8&#x27;));\n  const pluginConfig = {\n    ...config,\n    &#x2F;&#x2F; index.html 文件位置，用于webview加载\n    sourceFile: path.join(fileUrl, &#96;..&#x2F;${config.main || &#x27;index.html&#x27;}&#96;),\n    id: uuidv4(),\n    type: &#x27;dev&#x27;,\n    icon: &#x27;image:&#x2F;&#x2F;&#x27; + path.join(fileUrl, &#96;..&#x2F;${config.logo}&#96;),\n    subType: (() =&gt; {\n      if (config.main) {\n        return &#x27;&#x27;\n      }\n      return &#x27;template&#x27;;\n    })()\n  };\n}\n</code></pre><p>实现效果如下：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b40162dd4c774a3ca6db2aa63c3606eb~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>接下来就是进行命令搜索插件:</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/236e9308fa324a3bac266ff7332cd1ab~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>实现这个功能其实也就是对之前存储的<code>pluginConfig</code>的里面的 <code>features</code> 进行遍历，找到相应的 <code>cmd</code> 后进行下拉框展示即可。</p>\n<p>然后我们要去实现选择功能，用 <code>webview</code> 加载页面的能力：</p>\n<pre class=\"prettyprint language-html\"><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;webview id=&quot;webview&quot; :src=&quot;path&quot; :preload=&quot;preload&quot;&#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default {\n  data() {\n    return {\n      path: &#96;File:&#x2F;&#x2F;${this.$route.query.sourceFile}&#96;,\n      preload: &#96;File:&#x2F;&#x2F;${path.join(__static, &#x27;.&#x2F;preload.js&#x27;)}&#96;,\n      webview: null,\n      query: this.$route.query,\n      config: {}\n    }\n  }\n}\n&lt;&#x2F;script&gt;\n</code></pre><p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37cf1909b1374606bdd1fbae657433c7~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>到此结束了？并没有！！！由于篇幅的原因，我们后续再说。本出写的插件demo已上传github: <a href=\"https://github.com/clouDr-f2e/rubick-plugin-demo\">https://github.com/clouDr-f2e/rubick-plugin-demo</a></p>\n<h2>Far from enough 这只是开始</h2>\n<p>接下来我们就可以参考 <code>utools</code> 交互一口气实现其大部分功能：</p>\n<h3>超级面板</h3>\n<p><img src=\"//static.cnodejs.org/Fl-gy-iyc8sjhe0s9eOhJJRab8_M\" alt=\"image.png\"></p>\n<h3>加载utools生态插件</h3>\n<p>斗图：<a href=\"https://github.com/vst93/doutu-uToolsPlugin\">https://github.com/vst93/doutu-uToolsPlugin</a></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba1eb758180433294c93b59724adefd~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>窗口分离</h3>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4de3a72c7244db898b2106b96c48416~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>utools doc 模板</h3>\n<p>uTools 的插件开发给予了开发者最大的自由度，你可以随心所欲的设计页面结构、样式、交互，对于特别擅长前端开发的同学，这没有什么问题，但对于非前端开发者，要做出漂亮的、高质量的前端 UI 是一件困难的事情。</p>\n<p>所以 Rubick 也实现了模板能力：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1acf7f300d2490d99aa208080e00dad~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h3>utools 自带的系统命令</h3>\n<h4>取色</h4>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c3e00e5f08545bcb96613689649b337~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h4>截屏</h4>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18023dab52e1420c9e87362cefddb2a1~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<h2>最后</h2>\n<p>目前 <code>rubick</code> 已经实现 <code>utools</code> 大多数核心能力，<strong>最重要的是可以使用 utools 所有生态 ！</strong> 更多能力可以前往 github 体验。如果感觉有用，可以帮忙反手一个 star ✨</p>\n<p><a href=\"https://github.com/clouDr-f2e/rubick\">Rubick github</a></p>\n</div>",
      "title": "基于 Electron 我实现并开源了一个 uTools",
      "last_reply_at": "2021-08-02T16:56:49.020Z",
      "good": true,
      "top": false,
      "reply_count": 6,
      "visit_count": 2903,
      "create_at": "2021-07-07T01:30:39.811Z",
      "author": {
        "loginname": "muwoo",
        "avatar_url": "https://avatars.githubusercontent.com/u/21073039?v=4&s=120"
      }
    },
    {
      "id": "610016aae3e671439758fc52",
      "author_id": "5f322c8a2799ce64a0aabac9",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://hackertalk.net/post/207480410191056896\">阿里云还是 AWS？</a></p>\n</div>",
      "title": "阿里云还是 AWS？",
      "last_reply_at": "2021-08-02T16:51:47.168Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 356,
      "create_at": "2021-07-27T14:22:34.604Z",
      "author": {
        "loginname": "Q-Qplus1s",
        "avatar_url": "https://avatars.githubusercontent.com/u/50064165?v=4&s=120"
      }
    },
    {
      "id": "5b45c66a35342ab06906145a",
      "author_id": "57bbcb58b32043f532d40e6f",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><ul>\n<li><strong>Node Version</strong>: 8.11.3</li>\n<li><strong>Egg Version</strong>: 2.9.1</li>\n<li><strong>Plugin Name</strong>: egg-passport-local</li>\n<li><strong>Plugin Version</strong>: ^1.2.1</li>\n<li><strong>Platform</strong>:mac os</li>\n<li><strong>Mini Showcase Repository</strong>:</li>\n</ul>\n<hr>\n<p>因为写的是 api 接口，所以没有使用 <code>egg-passport-local</code> 进行用户账号密码的校验，也没有使用它来进行鉴权。</p>\n<p>目前的问题是：</p>\n<ul>\n<li>如果使用了 <code>egg-passport-local</code> 进行鉴权的话，目前无法返回正确的错误信息给前端。</li>\n<li>如果不使用该插件，无法操作 <code>ctx.user</code><pre class=\"prettyprint language-bash\"><code>Cannot set property user of #&lt;Object&gt; which has only a getter\n</code></pre></li>\n</ul>\n<p>针对这俩问题：</p>\n<ul>\n<li>能否使用 <code>egg-passport-local</code> 进行鉴权，并且可以手动处理具体的错误信息？</li>\n<li>能否不使用 <code>egg-passport-local</code> 鉴权，但是依旧可以往 <code>ctx.user</code> 中写数据？</li>\n</ul>\n</div>",
      "title": "不使用 passport-local 如何进行鉴权？",
      "last_reply_at": "2021-08-02T16:47:10.592Z",
      "good": false,
      "top": false,
      "reply_count": 20,
      "visit_count": 3644,
      "create_at": "2018-07-11T08:57:14.934Z",
      "author": {
        "loginname": "JZLeung",
        "avatar_url": "https://avatars.githubusercontent.com/u/7995232?v=4&s=120"
      }
    },
    {
      "id": "61058e37a5d29d4c6c2d3c29",
      "author_id": "5a051be2ee9b35da75a869f7",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>本篇为 <a href=\"https://cnodejs.org/topic/60f58c8ae3e67138bc58eacc\">深入学习 NodeJs 系列</a> 最新发布的 <a href=\"https://github.com/xiaoxiaojx/blog/issues/14\">c++ 插件运行</a>, 因为包含了基础介绍、如何使用、源码实现以及最后的实践例子, 自我感觉还算讲明白了 👀 所以单独分享了出来，更多可以持续关注 🌟 <a href=\"https://github.com/xiaoxiaojx/blog\">github | blog</a> 🌟</p>\n</blockquote>\n<p><img src=\"https://nodejs.org/static/images/logo.svg\" alt=\"https://nodejs.org/static/images/logo.svg\"></p>\n<h2>前言</h2>\n<p>node 中主要有 c++ 模块，lib 目录下的 js 模块，用户的 js 模块以及用户的 c++ 插件模块。其注册，运行，加载的机制都有所不同，下面让我们逐一讲解它们的实现</p>\n<p>涉及的知识点</p>\n<ul>\n<li><a href=\"http://nodejs.cn/latest-api/policy.html\">policy | Node.js API 文档</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/106781089\">C语言的静态链接与动态链接</a></li>\n<li><a href=\"https://www.cnblogs.com/anker/p/3746802.html\">采用dlopen、dlsym、dlclose加载动态链接库</a></li>\n</ul>\n<h2>简单介绍</h2>\n<blockquote>\n<p>插件是用 C++ 编写的动态链接共享对象。 require() 函数可以将插件加载为普通的 Node.js 模块。 插件提供了 JavaScript 和 C/C++ 库之间的接口。</p>\n</blockquote>\n<blockquote>\n<p>实现插件有三种选择：Node-API、nan 或直接使用内部 V8、libuv 和 Node.js 库。 除非需要直接访问 Node-API 未暴露的功能，否则请使用 Node-API。 有关 Node-API 的更多信息，请参阅使用 <a href=\"http://nodejs.cn/api/n-api.html\">Node-API 的 C/C++ 插件</a>。</p>\n</blockquote>\n<p>其实无论是 <a href=\"http://nodejs.cn/api/n-api.html\">Node-API</a> 还是 <a href=\"https://github.com/nodejs/node-addon-api\">node-addon-api</a>，都是最基本的 c++ 插件写法的封装，本篇让我们去了解一下 基本的 c++ 插件实现</p>\n<h2>例子</h2>\n<ul>\n<li>例子代码放在了该 <a href=\"https://github.com/xiaoxiaojx/blog/tree/master/addons\">git 仓库 addons 目录</a></li>\n<li>运行时的 node 版本为: 16.5.0</li>\n<li>运行的系统为: MacOS</li>\n</ul>\n<p>如下就是一个 c++ 插件的写法，module.exports 上导出了一个 hello 方法，其中 NODE_MODULE 宏主要是把该插件模块给注册到了内部的 modlist_internal 链表中，以便用户 require 的时候找到该模块</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; hello.cc\n\n#include &lt;node.h&gt;\n\nnamespace demo\n{\n\n  using v8::FunctionCallbackInfo;\n  using v8::Isolate;\n  using v8::Local;\n  using v8::Object;\n  using v8::String;\n  using v8::Value;\n\n  void Method(const FunctionCallbackInfo&lt;Value&gt; &amp;args)\n  {\n    Isolate *isolate = args.GetIsolate();\n    args.GetReturnValue().Set(String::NewFromUtf8(\n                                  isolate, &quot;world&quot;)\n                                  .ToLocalChecked());\n  }\n\n  void Initialize(Local&lt;Object&gt; exports)\n  {\n    NODE_SET_METHOD(exports, &quot;hello&quot;, Method);\n  }\n\n  NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)\n\n}\n</code></pre><h3>构建</h3>\n<p>构建运行 <a href=\"http://hello.cc\">hello.cc</a> 主要需要如下几步</p>\n<h4>下载 node-gyp</h4>\n<pre class=\"prettyprint\"><code>npm install -g node-gyp\n</code></pre><blockquote>\n<p>node-gyp 是一个用 Node.js 编写的跨平台命令行工具，用于为 Node.js 编译本机插件模块。它包含 Chromium 团队以前使用的 gyp-next 项目的供应商副本，扩展为支持 Node.js 原生插件的开发。</p>\n</blockquote>\n<h4>新增 binding.gyp 文件</h4>\n<p>文件内容如下</p>\n<pre class=\"prettyprint\"><code>{\n  &quot;targets&quot;: [\n    {\n      &quot;target_name&quot;: &quot;addon&quot;,\n      &quot;sources&quot;: [ &quot;hello.cc&quot; ]\n    }\n  ]\n}\n</code></pre><blockquote>\n<p>编写源代码后，必须将其编译为二进制 addon.node 文件。 为此，请在项目的顶层创建名为 binding.gyp 的文件，使用类似 JSON 的格式描述模块的构建配置。 该文件由 node-gyp 使用，这是一个专门为编译 Node.js 插件而编写的工具。</p>\n</blockquote>\n<h4>运行 node-gyp configure 命令</h4>\n<pre class=\"prettyprint\"><code>node-gyp configure\n</code></pre><blockquote>\n<p>创建 binding.gyp 文件后，使用 node-gyp configure 为当前平台生成适当的项目构建文件。 这将在 build/ 目录中生成 Makefile（在 Unix 平台上）或 vcxproj 文件（在 Windows 上）。</p>\n</blockquote>\n<h4>运行 node-gyp build 命令</h4>\n<pre class=\"prettyprint\"><code>node-gyp build\n</code></pre><blockquote>\n<p>接下来，调用 node-gyp build 命令生成编译后的 addon.node 文件。 这将被放入 build/Release/ 目录。</p>\n</blockquote>\n<h3>使用</h3>\n<blockquote>\n<p>构建完成后，可以通过将 require() 指向构建的 addon.node 模块在 Node.js 中使用二进制插件</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; main.js\n\nconst addon = require(&#x27;.&#x2F;build&#x2F;Release&#x2F;addon&#x27;);\n\nconsole.log(addon.hello());\n&#x2F;&#x2F; 打印: &#x27;world&#x27;\n</code></pre><h2>实现</h2>\n<p>当代码中 require 的是编译后的 c++ 插件 .node 文件时的处理函数如下</p>\n<ul>\n<li>其主要的实现为 process.dlopen 函数</li>\n<li>代码开始的 policy 为 Node.js 包含对创建加载代码的策略的实验性支持, 比如运行 node --experimental-policy=policy.json app.js, 其具体用处可以参考 <a href=\"http://nodejs.cn/latest-api/policy.html\">policy | Node.js API 文档</a></li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; lib&#x2F;internal&#x2F;modules&#x2F;cjs&#x2F;loader.js\n\nModule._extensions[&#x27;.node&#x27;] = function(module, filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL, content);\n  }\n  &#x2F;&#x2F; Be aware this doesn&#x27;t use &#96;content&#96;\n  return process.dlopen(module, path.toNamespacedPath(filename));\n};\n</code></pre><h3>动态链接</h3>\n<p>dlopen 主要用于动态打开一个 c++ 插件文件，运行其代码, 说 dlopen 之前我们先说一下动态链接。</p>\n<h4>js 里面的动态</h4>\n<p>如果拿 js 来举例的话, 正常运行一个 js 文件直接通过 script 直接引用交给浏览器运行即可，不需要额外的干预。比如你想动态加载运行一个 js, 就需要封装一个 dynamicImport 方法，等到实际会调用的时候才去动态加载运行，这个 dynamicImport 程序可能就是通过 document.createElement(‘script’) 去实现</p>\n<h4>C语言的静态链接与动态链接</h4>\n<blockquote>\n<p>内容来自 <a href=\"https://zhuanlan.zhihu.com/p/106781089\">C语言的静态链接与动态链接</a></p>\n</blockquote>\n<p>什么是链接？</p>\n<blockquote>\n<p>对于初学C语言的朋友，可能对链接这个概念有点陌生，这里简单介绍一下。我们的C代码编译生成可执行程序会经过如下过程：</p>\n</blockquote>\n<p><img src=\"https://user-images.githubusercontent.com/23253540/127743223-40c7f667-7e07-4398-8c44-f5694fb387f8.png\" alt=\"image\"></p>\n<p>1、什么是静态链接？</p>\n<blockquote>\n<p>静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。链接器是一个独立程序，将一个或多个库或目标文件（先前由编译器或汇编器生成）链接到一块生成可执行程序。这里的库指的是静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。</p>\n</blockquote>\n<p>2、什么是动态链接？</p>\n<blockquote>\n<p>动态链接（Dynamic Linking），把链接这个过程推迟到了运行时再进行，在可执行文件装载时或运行时，由操作系统的装载程序加载库。这里的库指的是动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。值得一提的是，在Windows下的动态链接也可以用到.lib为后缀的文件，但这里的.lib文件叫做导入库，是由.dll文件生成的。</p>\n</blockquote>\n<h3>DLOpen</h3>\n<p>DLOpen 的实现过程主要为如下几步，后面我们在详细分析一下其中重要的步骤</p>\n<ol>\n<li>对传入的参数进行了一些校验，保存 js 传入的 module 对象，并检查需要存在 exports 属性</li>\n<li>调用 env-&gt;TryLoadAddon 方法来试图加载插件, TryLoadAddon 函数主要是调用了传入的回调函数</li>\n<li>回调函数一开始就进行了上锁操作 Mutex::ScopedLock lock(dlib_load_mutex);</li>\n<li>然后调用 dlib-&gt;Open() 方法获取动态链接库文件的句柄</li>\n<li>上一步骤的 dlib-&gt;Open() 一运行，c++ 插件的代码其实就已经运行完毕，回顾我们上面例子的 c++ 插件代码，其 NODE_MODULE 宏就会注册该模块到内存中了</li>\n<li>if (mp != nullptr) 判断是否已经通过 NODE_MODULE 主动注册，这样一说其实可以自动动注册</li>\n<li>如果注册成功调用 dlib-&gt;SaveInGlobalHandleMap 保存 dlib-&gt;Open() 返回的句柄到内存中</li>\n<li>否则通过 auto callback = GetInitializerCallback(dlib) 返回值查看是否可以自动帮助用户注册</li>\n<li>dlib-&gt;Open() 打开过程结束，通过 Mutex::ScopedUnlock unlock(lock) 解锁</li>\n<li>调用 mp-&gt;nm_register_func 函数其实是上面 c++ 插件例子中用户传入的 Initialize 函数</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; src&#x2F;node_binding.cc\n\nvoid DLOpen(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Environment* env = Environment::GetCurrent(args);\n  auto context = env-&gt;context();\n\n  CHECK_NULL(thread_local_modpending);\n\n  if (args.Length() &lt; 2) {\n    return THROW_ERR_MISSING_ARGS(\n        env, &quot;process.dlopen needs at least 2 arguments&quot;);\n  }\n\n  int32_t flags = DLib::kDefaultFlags;\n  if (args.Length() &gt; 2 &amp;&amp; !args[2]-&gt;Int32Value(context).To(&amp;flags)) {\n    return THROW_ERR_INVALID_ARG_TYPE(env, &quot;flag argument must be an integer.&quot;);\n  }\n\n  Local&lt;Object&gt; module;\n  Local&lt;Object&gt; exports;\n  Local&lt;Value&gt; exports_v;\n  if (!args[0]-&gt;ToObject(context).ToLocal(&amp;module) ||\n      !module-&gt;Get(context, env-&gt;exports_string()).ToLocal(&amp;exports_v) ||\n      !exports_v-&gt;ToObject(context).ToLocal(&amp;exports)) {\n    return;  &#x2F;&#x2F; Exception pending.\n  }\n\n  node::Utf8Value filename(env-&gt;isolate(), args[1]);  &#x2F;&#x2F; Cast\n  env-&gt;TryLoadAddon(*filename, flags, [&amp;](DLib* dlib) {\n    static Mutex dlib_load_mutex;\n    Mutex::ScopedLock lock(dlib_load_mutex);\n\n    const bool is_opened = dlib-&gt;Open();\n\n    &#x2F;&#x2F; Objects containing v14 or later modules will have registered themselves\n    &#x2F;&#x2F; on the pending list.  Activate all of them now.  At present, only one\n    &#x2F;&#x2F; module per object is supported.\n    node_module* mp = thread_local_modpending;\n    thread_local_modpending = nullptr;\n\n    if (!is_opened) {\n      std::string errmsg = dlib-&gt;errmsg_.c_str();\n      dlib-&gt;Close();\n#ifdef _WIN32\n      &#x2F;&#x2F; Windows needs to add the filename into the error message\n      errmsg += *filename;\n#endif  &#x2F;&#x2F; _WIN32\n      THROW_ERR_DLOPEN_FAILED(env, errmsg.c_str());\n      return false;\n    }\n\n    if (mp != nullptr) {\n      if (mp-&gt;nm_context_register_func == nullptr) {\n        if (env-&gt;force_context_aware()) {\n          dlib-&gt;Close();\n          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);\n          return false;\n        }\n      }\n      mp-&gt;nm_dso_handle = dlib-&gt;handle_;\n      dlib-&gt;SaveInGlobalHandleMap(mp);\n    } else {\n      if (auto callback = GetInitializerCallback(dlib)) {\n        callback(exports, module, context);\n        return true;\n      } else if (auto napi_callback = GetNapiInitializerCallback(dlib)) {\n        napi_module_register_by_symbol(exports, module, context, napi_callback);\n        return true;\n      } else {\n        mp = dlib-&gt;GetSavedModuleFromGlobalHandleMap();\n        if (mp == nullptr || mp-&gt;nm_context_register_func == nullptr) {\n          dlib-&gt;Close();\n          char errmsg[1024];\n          snprintf(errmsg,\n                   sizeof(errmsg),\n                   &quot;Module did not self-register: &#x27;%s&#x27;.&quot;,\n                   *filename);\n          THROW_ERR_DLOPEN_FAILED(env, errmsg);\n          return false;\n        }\n      }\n    }\n\n    &#x2F;&#x2F; -1 is used for N-API modules\n    if ((mp-&gt;nm_version != -1) &amp;&amp; (mp-&gt;nm_version != NODE_MODULE_VERSION)) {\n      &#x2F;&#x2F; Even if the module did self-register, it may have done so with the\n      &#x2F;&#x2F; wrong version. We must only give up after having checked to see if it\n      &#x2F;&#x2F; has an appropriate initializer callback.\n      if (auto callback = GetInitializerCallback(dlib)) {\n        callback(exports, module, context);\n        return true;\n      }\n      char errmsg[1024];\n      snprintf(errmsg,\n               sizeof(errmsg),\n               &quot;The module &#x27;%s&#x27;&quot;\n               &quot;\\nwas compiled against a different Node.js version using&quot;\n               &quot;\\nNODE_MODULE_VERSION %d. This version of Node.js requires&quot;\n               &quot;\\nNODE_MODULE_VERSION %d. Please try re-compiling or &quot;\n               &quot;re-installing\\nthe module (for instance, using &#96;npm rebuild&#96; &quot;\n               &quot;or &#96;npm install&#96;).&quot;,\n               *filename,\n               mp-&gt;nm_version,\n               NODE_MODULE_VERSION);\n\n      &#x2F;&#x2F; NOTE: &#96;mp&#96; is allocated inside of the shared library&#x27;s memory, calling\n      &#x2F;&#x2F; &#96;dlclose&#96; will deallocate it\n      dlib-&gt;Close();\n      THROW_ERR_DLOPEN_FAILED(env, errmsg);\n      return false;\n    }\n    CHECK_EQ(mp-&gt;nm_flags &amp; NM_F_BUILTIN, 0);\n\n    &#x2F;&#x2F; Do not keep the lock while running userland addon loading code.\n    Mutex::ScopedUnlock unlock(lock);\n    if (mp-&gt;nm_context_register_func != nullptr) {\n      mp-&gt;nm_context_register_func(exports, module, context, mp-&gt;nm_priv);\n    } else if (mp-&gt;nm_register_func != nullptr) {\n      mp-&gt;nm_register_func(exports, module, mp-&gt;nm_priv);\n    } else {\n      dlib-&gt;Close();\n      THROW_ERR_DLOPEN_FAILED(env, &quot;Module has no declared entry point.&quot;);\n      return false;\n    }\n\n    return true;\n  });\n\n  &#x2F;&#x2F; Tell coverity that &#x27;handle&#x27; should not be freed when we return.\n  &#x2F;&#x2F; coverity[leaked_storage]\n}\n</code></pre><h3>env-&gt;TryLoadAddon</h3>\n<ol>\n<li>loaded_addons_.emplace_back 向 loaded_addons_ 队列尾部添加一个元素</li>\n<li>调用传入的回调函数 was_loaded</li>\n<li>如果 was_loaded 失败则 loaded_addons_.pop_back 移除尾部的一个元素</li>\n</ol>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; src&#x2F;env-inl.h\n\ninline void Environment::TryLoadAddon(\n    const char* filename,\n    int flags,\n    const std::function&lt;bool(binding::DLib*)&gt;&amp; was_loaded) {\n  loaded_addons_.emplace_back(filename, flags);\n  if (!was_loaded(&amp;loaded_addons_.back())) {\n    loaded_addons_.pop_back();\n  }\n}\n</code></pre><h3>dlib-&gt;Open</h3>\n<ol>\n<li>dlopen 以指定模式打开指定的动态连接库文件，并返回一个句柄给调用进程</li>\n<li>dlerror 获取可能会出现的错误</li>\n</ol>\n<pre class=\"prettyprint\"><code>bool DLib::Open() {\n  handle_ = dlopen(filename_.c_str(), flags_);\n  if (handle_ != nullptr) return true;\n  errmsg_ = dlerror();\n  return false;\n}\n</code></pre><h3>插件的注册</h3>\n<p>运行完上面的 dlib-&gt;Open 函数，用户的代码也被加载且运行了，如同上面的 c++ 插件例子中调用 NODE_MODULE 宏主要用于注册模块</p>\n<p>插件的注册的实现主要是 node_module_register 函数，其实就是向链表 modlist_internal 中插入了一项数据，但是下面 NODE_C_CTOR 宏能让我们学到不少知识</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; src&#x2F;node.h\n\n#define NODE_MODULE(modname, regfunc)                                 \\\n  NODE_MODULE_X(modname, regfunc, NULL, 0)  &#x2F;&#x2F; NOLINT (readability&#x2F;null_usage)\n  \n#define NODE_MODULE_X(modname, regfunc, priv, flags)                  \\\n  extern &quot;C&quot; {                                                        \\\n    static node::node_module _module =                                \\\n    {                                                                 \\\n      NODE_MODULE_VERSION,                                            \\\n      flags,                                                          \\\n      NULL,  &#x2F;* NOLINT (readability&#x2F;null_usage) *&#x2F;                    \\\n      __FILE__,                                                       \\\n      (node::addon_register_func) (regfunc),                          \\\n      NULL,  &#x2F;* NOLINT (readability&#x2F;null_usage) *&#x2F;                    \\\n      NODE_STRINGIFY(modname),                                        \\\n      priv,                                                           \\\n      NULL   &#x2F;* NOLINT (readability&#x2F;null_usage) *&#x2F;                    \\\n    };                                                                \\\n    NODE_C_CTOR(_register_ ## modname) {                              \\\n      node_module_register(&amp;_module);                                 \\\n    }                                                                 \\\n  }\n  \n#define NODE_C_CTOR(fn)                                               \\\n  NODE_CTOR_PREFIX void fn(void) __attribute__((constructor));        \\\n  NODE_CTOR_PREFIX void fn(void)\n  \n# define NODE_CTOR_PREFIX static\n</code></pre><h4>NODE_C_CTOR</h4>\n<p>NODE_C_CTOR 宏这段实现可有点优秀，其主要是声明了一个动态函数 <em>register</em> ## modname，并且立马调用了 <em>register</em> ## modname 函数，其作用类似于下面的例子, 例子放在了该 git 仓库 <a href=\"https://github.com/xiaoxiaojx/blog/blob/master/demo_NODE_C_CTOR.cpp\">demo_NODE_C_CTOR.cpp</a></p>\n<p>通过 NODE_C_CTOR 宏声明了 <em>register</em> 函数，且通过 <strong>attribute</strong>((constructor)) 使得 <em>register</em> 函数 运行会在 main 函数之前</p>\n<pre class=\"prettyprint\"><code>#include &lt;iostream&gt;\n\n# define NODE_CTOR_PREFIX static\n\n#define NODE_C_CTOR(fn)                                               \\\n  NODE_CTOR_PREFIX void fn(void) __attribute__((constructor));        \\\n  NODE_CTOR_PREFIX void fn(void)\n\nusing namespace std;\n\nNODE_C_CTOR(_register_) {                              \\\n    std::cout &lt;&lt; &quot;before main function&quot; &lt;&lt; std::endl;                               \\\n}\n\nint main()\n{\n  char site[] = &quot;Hello, world!&quot;;\n  cout &lt;&lt; site &lt;&lt; endl;\n  return 0;\n}\n</code></pre><h3>如果不注册</h3>\n<h4>GetInitializerCallback</h4>\n<p>如果用户没有调用 NODE_MODULE 宏注册, 发现会进入 auto callback = GetInitializerCallback(dlib) 这个代码逻辑</p>\n<ul>\n<li>下面的代码 “node_register_module_v” STRINGIFY(NODE_MODULE_VERSION) 在 c 中其实是相当于两个字符串拼接的意思, 如果 NODE_MODULE_VERSION 的值是 95， 变量 name 即等于 node_register_module_v95</li>\n<li>dlsym 函数相当于获取 c++ 插件中的指定 name 的地址引用，即通过句柄和连接符名称获取函数名或者变量名。</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; src&#x2F;node_binding.cc\n\ninline InitializerCallback GetInitializerCallback(DLib* dlib) {\n  const char* name = &quot;node_register_module_v&quot; STRINGIFY(NODE_MODULE_VERSION);\n  return reinterpret_cast&lt;InitializerCallback&gt;(dlib-&gt;GetSymbolAddress(name));\n}\n\nvoid* DLib::GetSymbolAddress(const char* name) {\n  return dlsym(handle_, name);\n}\n</code></pre><p>所以说如果用户没有显示调用 NODE_MODULE 宏注册，会查看 c++ 插件中是否有 node_register_module_v95 函数，如果有的话则主动调用该函数，后面找到了这个 node 实现的 commit <a href=\"https://github.com/nodejs/node/commit/3828fc62\">3828fc62</a></p>\n<p>如果不用 NODE_MODULE 宏注册则可以通过下面的例子去实现, 例子放在了该 git 仓库 <a href=\"https://github.com/xiaoxiaojx/blog/blob/master/demo_NODE_MODULE_INITIALIZER.cc\">demo_NODE_MODULE_INITIALIZER.cc</a></p>\n<pre class=\"prettyprint\"><code>#include &lt;node.h&gt;\n#include &lt;v8.h&gt;\n\nstatic void Method(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args) {\n  v8::Isolate* isolate = args.GetIsolate();\n  args.GetReturnValue().Set(v8::String::NewFromUtf8(\n        isolate, &quot;world&quot;).ToLocalChecked());\n}\n\n&#x2F;&#x2F; NODE_MODULE_EXPORT 宏等同于 __attribute__((visibility(&quot;default&quot;)))\n&#x2F;&#x2F; NODE_MODULE_INITIALIZER 宏等同于 &quot;node_register_module_v&quot; STRINGIFY(NODE_MODULE_VERSION)\n\nextern &quot;C&quot; NODE_MODULE_EXPORT void\nNODE_MODULE_INITIALIZER(v8::Local&lt;v8::Object&gt; exports,\n                        v8::Local&lt;v8::Value&gt; module,\n                        v8::Local&lt;v8::Context&gt; context) {\n  NODE_SET_METHOD(exports, &quot;hello&quot;, Method);\n}\n</code></pre><p>其出现这种情况的原因为 dlopen 多次运行后面就不会再运行 c++ 插件里面的代码，类比于 node 的 require 机制，所以 NODE_MODULE 宏第二次直接就没有注册，而通过 NODE_MODULE_INITIALIZER 声明了一个函数，后面每次通过 dlsym 获取到该函数引用地址去主动调用一次该函数就好了，下面是<a href=\"http://nodejs.cn/api/addons.html#addons_context_aware_addons\">官网 | 上下文感知的插件</a> 的解释</p>\n<blockquote>\n<p>在某些环境中，可能需要在多个上下文中多次加载 Node.js 插件。 例如，Electron 运行时在单个进程中运行多个 Node.js 实例。 每个实例都有自己的 require() 缓存，因此当通过 require() 加载时，每个实例都需要原生插件才能正确运行。 这意味着插件必须支持多个初始化。\n可以使用宏 NODE_MODULE_INITIALIZER 构建上下文感知插件，该宏扩展为 Node.js 在加载插件时期望找到的函数的名称。</p>\n</blockquote>\n<h4>GetNapiInitializerCallback</h4>\n<p>在 DLOpen 函数中 GetInitializerCallback 后还有另一个分支逻辑 GetNapiInitializerCallback 函数的调用，其实两个函数的作用是类似的, 这里的看函数名字应该是为 napi 留下的口子</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; src&#x2F;node_binding.cc\n\ninline napi_addon_register_func GetNapiInitializerCallback(DLib* dlib) {\n  const char* name =\n      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);\n  return reinterpret_cast&lt;napi_addon_register_func&gt;(\n      dlib-&gt;GetSymbolAddress(name));\n}\n</code></pre><p>napi 插件的例子, 代码放在了该 git 仓库 <a href=\"https://github.com/xiaoxiaojx/blog/blob/master/demo_NAPI_MODULE_INIT.cc\">demo_NAPI_MODULE_INIT.cc</a></p>\n<pre class=\"prettyprint\"><code>#include &lt;assert.h&gt;\n#include &lt;node_api.h&gt;\n\n&#x2F;&#x2F; 调用 NAPI_MODULE_INIT 注册插件的例子\n\nstatic int32_t increment = 0;\n\nstatic napi_value Hello(napi_env env, napi_callback_info info) {\n  napi_value result;\n  napi_status status = napi_create_int32(env, increment++, &amp;result);\n  assert(status == napi_ok);\n  return result;\n}\n\nNAPI_MODULE_INIT() {\n  napi_value hello;\n  napi_status status =\n      napi_create_function(env,\n                           &quot;hello&quot;,\n                           NAPI_AUTO_LENGTH,\n                           Hello,\n                           NULL,\n                           &amp;hello);\n  assert(status == napi_ok);\n  status = napi_set_named_property(env, exports, &quot;hello&quot;, hello);\n  assert(status == napi_ok);\n  return exports;\n}\n</code></pre><h2>优秀的插件推荐</h2>\n<p>起因是自己写的一个 FaaS 接口，当前 qps 在 30 左右，在监控上发现系统内存是随着时间缓慢上升 📈, 这个接口 \tqps 预期全量会达到 1000 左右，现在就有内存泄漏可要赶紧排查出来 !</p>\n<p>一开始我的想法是在接口上开个口子，比如查询的时候 url 拼上参数 get_v8_heapSnapshot 就返回当前进程 v8 堆的快照，隔一段时间拉取几次来去分析</p>\n<p>后面发现自动接入了 Easy-Monitor 里面就能非常快速的满足这个需求, 可以直接点击 devtools 在线分析也能下载到本地分析快照\n<img src=\"https://user-images.githubusercontent.com/23253540/127746359-7b19f755-911f-41c6-a477-8f927e4ecaa2.png\" alt=\"image\"></p>\n<p>后面对比了几个不同时间的快照发现无明显变化，看堆空间趋势图也无明显波动，确认为物理机其他进程程序所致是预期内的，我们的 node 进程没有内存泄漏\n<img src=\"https://user-images.githubusercontent.com/23253540/127746477-8ea2b3ef-935f-4339-9399-bd7427d1874e.png\" alt=\"image\"></p>\n<p>该 c++ 插件的实现在 <a href=\"https://github.com/X-Profiler/xprofiler\">X-Profiler/xprofiler</a> 仓库, 更多介绍见文章 <a href=\"https://cnodejs.org/topic/5ee1ee83b703280f0bcb922a\">Easy-Monitor 3.0 开源 - 基于 Addon 的 Node.js 性能监控解决方案</a>, 算是最佳实践了, 给大佬们打 call 👏</p>\n<h2>小结</h2>\n<p>node 中运行一个 c++ 插件的实现主要是在 DLOpen 函数中，DLOpen 核心是调用了下面几个函数</p>\n<blockquote>\n<p>函数介绍来自于文章 <a href=\"https://www.cnblogs.com/anker/p/3746802.html\">采用dlopen、dlsym、dlclose加载动态链接库</a></p>\n</blockquote>\n<pre class=\"prettyprint\"><code>#include &lt;dlfcn.h&gt;\n\n&#x2F;&#x2F; dlopen以指定模式打开指定的动态连接库文件\nvoid *dlopen(const char *filename, int flag);\n\n&#x2F;&#x2F; dlerror返回出现的错误\nchar *dlerror(void);\n\n&#x2F;&#x2F; dlsym通过句柄和连接符名称获取函数名或者变量名\nvoid *dlsym(void *handle, const char *symbol);\n\n&#x2F;&#x2F; dlclose来卸载打开的库\nint dlclose(void *handle);\n</code></pre></div>",
      "title": "NodeJs C++ 插件的实现",
      "last_reply_at": "2021-08-02T16:46:19.093Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 457,
      "create_at": "2021-07-31T17:53:59.705Z",
      "author": {
        "loginname": "xiaoxiaojx",
        "avatar_url": "https://avatars.githubusercontent.com/u/23253540?v=4&s=120"
      }
    },
    {
      "id": "60e2e45aba7460ad8d862567",
      "author_id": "60e2e2ccba7460203986255b",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><a href=\"https://www.bilibili.com/video/BV1hM4y1u7B4\"><img src=\"//static.cnodejs.org/Fh6glLHJh9_kScZjSM0LPj3UpxAC\" alt=\"image.png\"></a>\n<strong>↑↑↑ 全程 110 分钟干货分享视频 ↑↑↑</strong></p>\n<h2>TSRPC 是什么</h2>\n<p>TSRPC 是一个 TypeScript 的 RPC 框架，适用于浏览器 Web 应用、WebSocket 实时应用、NodeJS 微服务等场景。\n是目前世界上唯一支持 TypeScript 复杂类型运行时检测和二进制序列化的 RPC 框架</p>\n<p>中文文档：<a href=\"https://tsrpc.cn\">https://tsrpc.cn</a>\nGitHub：<a href=\"https://github.com/k8w/tsrpc\">https://github.com/k8w/tsrpc</a>\n视频教程：<a href=\"https://www.bilibili.com/video/BV1hM4y1u7B4\">https://www.bilibili.com/video/BV1hM4y1u7B4</a></p>\n<p>目前，大多数项目仍在使用传统的 Restful API 进行前后端通信，这存在一些痛点。</p>\n<ol>\n<li>依赖文档进行协议定义，前后端联调常被低级错误困扰（如字段名大小写错误，字段类型错误等）。</li>\n<li>一些框架虽然实现了协议定义规范，但需要引入 <a href=\"https://www.typescriptlang.org/docs/handbook/decorators.html#decorators\">Decorator</a> 或第三方 IDL 语言。</li>\n<li>一些框架虽然实现了类型校验，但无法支持 TypeScript 的高级类型，例如业务中常见的 <a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\">Union Type</a>：</li>\n</ol>\n<pre class=\"prettyprint language-ts\"><code>&#x2F;&#x2F; 用户信息\ninterface UserInfo {\n  &#x2F;&#x2F; 来源渠道\n  from: { type: &#x27;老用户邀请&#x27;, fromUserId: string }\n    | { type: &#x27;推广链接&#x27;, url: string }\n    | { type: &#x27;直接进入&#x27; },\n  &#x2F;&#x2F; 注册时间\n  createTime: Date\n}\n</code></pre><ol>\n<li>JSON 支持的类型有限，例如不支持 <code>ArrayBuffer</code>，实现文件上传会非常麻烦。</li>\n<li>请求和响应都是明文，破解门槛太低，字符串加密方式有限且强度不够。</li>\n<li>等等…</li>\n</ol>\n<p>我们无法找到一个能完美解决这些问题的现成框架，于是我们全新设计和创造了 <strong>TSRPC</strong> 。</p>\n<h2>概览</h2>\n<p>一个名为 <code>Hello</code> 的协议，从定义、实现到浏览器调用。</p>\n<h3>协议定义</h3>\n<p>直接使用 <code>type</code> 或 <code>interface</code> 定义协议，无需 Decorator 和第三方 IDL 语言。</p>\n<pre class=\"prettyprint language-ts\"><code>export interface ReqHello {\n  name: string;\n}\n\nexport interface ResHello {\n  reply: string;\n}\n</code></pre><h3>服务端实现</h3>\n<p>运行时自动校验类型，请求参数一定类型安全。</p>\n<pre class=\"prettyprint language-ts\"><code>import { ApiCall } from &quot;tsrpc&quot;;\n\nexport async function ApiHello(call: ApiCall&lt;ReqHello, ResHello&gt;) {\n  call.succ({\n    reply: &#x27;Hello, &#x27; + call.req.name\n  });\n}\n</code></pre><h3>客户端调用</h3>\n<p>跨项目复用协议定义，全程代码提示，不需要接口文档。</p>\n<pre class=\"prettyprint language-ts\"><code>let ret = await client.callApi(&#x27;Hello&#x27;, {\n    name: &#x27;World&#x27;\n});\nconsole.log(ret); &#x2F;&#x2F; { isSucc: true, res: { reply: &#x27;Hello, World&#x27; } }\n</code></pre><p><img src=\"//static.cnodejs.org/FlCzOaoeVOyuFpf5G14FtEw09s7X\" alt=\"code-hint.gif\"></p>\n<h2>特性</h2>\n<p>TSRPC 具有一些前所未有的强大特性，给您带来极致的开发体验。</p>\n<ul>\n<li>🥤 <strong>原汁原味 TypeScript</strong>\n<ul>\n<li>直接基于 TypeScript <code>type</code> 和 <code>interface</code> 定义协议</li>\n<li>无需额外注释，无需 Decorator，无需第三方 IDL 语言</li>\n</ul>\n</li>\n<li>👓 <strong>自动类型检查</strong>\n<ul>\n<li>在编译时刻和运行时刻，自动进行输入输出的类型检查</li>\n<li>总是类型安全，放心编写业务代码</li>\n</ul>\n</li>\n<li>💾 <strong>二进制序列化</strong>\n<ul>\n<li>比 JSON 更小的传输体积</li>\n<li>比 JSON 更多的数据类型：如 <code>Date</code>, <code>ArrayBuffer</code>, <code>Uint8Array</code> 等</li>\n<li>方便地实现二进制加密</li>\n</ul>\n</li>\n<li>🔥 <strong>史上最强大的 TypeScript 序列化算法</strong>\n<ul>\n<li>无需任何注解，直接实现将 TypeScript 源码中的类型定义序列化</li>\n<li>首个也是目前唯一支持 TypeScript 高级类型的二进制序列化算法，包括：\n<ul>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types\">Union Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types\">Intersection Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys\">Pick Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype\">Partial Type</a></li>\n<li><a href=\"https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html\">Indexed Access Types</a></li>\n<li>等等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>☎ <strong>多协议</strong>\n<ul>\n<li>同时支持 HTTP / WebSocket</li>\n</ul>\n</li>\n<li>💻 <strong>多平台</strong>\n<ul>\n<li>NodeJS / 浏览器 / App / 小程序</li>\n</ul>\n</li>\n<li>⚡️ <strong>高性能</strong>\n<ul>\n<li>单核单进程 5000+ QPS 吞吐量（测试于 Macbook Air M1, 2020)</li>\n<li>单元测试、压力测试、DevOps 方案齐备</li>\n<li>经过数个千万用户级项目验证</li>\n</ul>\n</li>\n</ul>\n<h2>兼容性</h2>\n<p>完全可以在 Server 端使用 TSRPC，同时兼容传统前端。</p>\n<ul>\n<li><strong>兼容 JSON 形式的 Restful API 调用</strong>\n<ul>\n<li>可自行使用 <code>XMLHttpRequest</code>、<code>fetch</code> 或其它 AJAX 框架以 JSON 方式调用接口</li>\n</ul>\n</li>\n<li><strong>兼容纯 JavaScript 的项目使用</strong>\n<ul>\n<li>可在纯 JavaScript 项目中使用 TSRPC Client，也能享受类型检查和序列化特性</li>\n</ul>\n</li>\n<li><strong>兼容 Internet Explorer 10 浏览器</strong>\n<ul>\n<li>浏览器端兼容至 IE 10 ，Chrome 30</li>\n</ul>\n</li>\n</ul>\n<h2>运行时类型检测的实现原理</h2>\n<p>众所周知，TypeScript 的类型检测仅发生在编译时刻，这是因为类型信息（如 <code>type</code>、<code>interface</code>）会在编译时刻被抹除。而 TSRPC 竟然能在运行时刻也检测这些被抹除的类型信息？\n况且 TypeScript 编译器有大几 MB，而 TSRPC 才几十 KB……</p>\n<p>其实，这是因为我们遵循 TypeScript 类型系统，独立实现了一套轻量的类型系统，可以在运行时完成类型检测，甚至是二进制序列化。它支持了绝大多数常用的 TypeScript 类型。</p>\n<p><a href=\"https://tsrpc.cn/docs/tsrpc-inside/supported-types\">支持的类型清单</a></p>\n<h2>上手试试</h2>\n<p>使用 <code>create-tsrpc-app</code> 工具，可以快速创建 TSRPC 项目。</p>\n<pre class=\"prettyprint language-shell\"><code>npx create-tsrpc-app@latest\n</code></pre><p>创建过程是交互式的，在菜单上选择相应的配置，即可轻松创建包含前后端的 TSRPC 全栈应用项目。</p>\n<p><img src=\"//static.cnodejs.org/Fs3Tg6Fa-wBoVRjowCUojIDxd42P\" alt=\"create-tsrpc-app.gif\"></p>\n<p>如果你选择创建 <strong>HTTP 短连接服务</strong>，则会创建一个留言板的演示项目；如果选择 <strong>WebSocket 长连接服务</strong>，则会创建一个实时聊天室的演示项目。</p>\n<h2>参考资料</h2>\n<p>GitHub：<a href=\"https://github.com/k8w/tsrpc\">https://github.com/k8w/tsrpc</a>\n中文文档：<a href=\"https://tsrpc.cn\">https://tsrpc.cn</a>\n视频教程：<a href=\"https://www.bilibili.com/video/BV1hM4y1u7B4\">https://www.bilibili.com/video/BV1hM4y1u7B4</a></p>\n</div>",
      "title": "[全程干货] TSRPC 和 TypeScript 全栈开发实践：前后端共享代码 / 运行时类型检测 / 二进制序列化",
      "last_reply_at": "2021-08-02T16:27:48.793Z",
      "good": false,
      "top": false,
      "reply_count": 16,
      "visit_count": 4125,
      "create_at": "2021-07-05T10:52:10.504Z",
      "author": {
        "loginname": "k8w",
        "avatar_url": "https://avatars.githubusercontent.com/u/1681689?v=4&s=120"
      }
    },
    {
      "id": "6103633da5d29d1d9f2d372b",
      "author_id": "5cab188c7edd13064e05363f",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>在n台机器的情况下貌似多进程效果更佳，每一个进程都是单线程，不用考虑锁，进程间共享的锁反正都得第三方。。还何必开多个线程还得在进程内处理线程锁呢。。\n多进程代表：nginx nodejs php\n多线程代表：java go</p>\n</div>",
      "title": "多线程or多进程",
      "last_reply_at": "2021-08-02T15:52:00.691Z",
      "good": false,
      "top": false,
      "reply_count": 7,
      "visit_count": 402,
      "create_at": "2021-07-30T02:26:05.989Z",
      "author": {
        "loginname": "ganshiqingyuan",
        "avatar_url": "https://avatars.githubusercontent.com/u/33950951?v=4&s=120"
      }
    },
    {
      "id": "6103ac7aa5d29d44e72d39d5",
      "author_id": "6103ac21a5d29d57b82d39ca",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>Blocking is when the execution of additional JavaScript in the Node.js process must wait until a non-JavaScript operation completes. This happens because the event loop is unable to continue running JavaScript while a blocking operation is occurring.</p>\n</div>",
      "title": "Node.js 官方关于非阻塞的文档中，addtional javascript 是什么含义，有没有实例？",
      "last_reply_at": "2021-08-02T09:24:22.505Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 330,
      "create_at": "2021-07-30T07:38:34.196Z",
      "author": {
        "loginname": "sdutwsl",
        "avatar_url": "https://avatars.githubusercontent.com/u/28350570?v=4&s=120"
      }
    },
    {
      "id": "607799714d20cbc44d68c484",
      "author_id": "5c81f15090c14711cc8cb87e",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h3>一、Serverless相关的概念</h3>\n<p>Serverless又名无服务器,所谓无服务器并非是说不需要依赖和依靠服务器等资源,而是开发者再也不用过多考虑服务器的问题,可以更专注在产品代码上。</p>\n<p><strong>Serverless相关视频教程</strong>：<a href=\"https://www.bilibili.com/video/BV12h411Q7wz?p=2\">https://www.bilibili.com/video/BV12h411Q7wz?p=2</a></p>\n<p>Serverless是一种软件系统架构的思想和方法，它不是软件框架、类库或者工具。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态（Stateless）、暂存（可能只存在于一次调用的过程中）计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时（运行时通俗的讲就是运行环境，比如nodejs环境，java环境，php环境）。Serverless真正做到了部署应用无需涉及基础设施的建设，自动构建、部署和启动服务。</p>\n<p><strong>通俗的讲：</strong>  Serverless 是构建和运行软件时不需要关心服务器的一种架构思想。老程序员都用过虚拟主机，刚开始学Serverless 你可以把它理解为虚拟主机的升级版本。\n<img src=\"//static.cnodejs.org/FrQYaZ4ed16DDtoKnmfMeyAR6cay\" alt=\"图片1.png\"></p>\n<p>虚拟主机已经是快被淘汰掉的上一代产物了。云计算涌现出很多改变传统IT架构和运维方式的新技术，比如虚拟机、容器、微服务，无论这些技术应用在哪些场景，降低成本、提升效率是云服务永恒的主题。Serverless的出现真正的解决了降低成本、提升效率的问题。它真正做到了弹性伸缩、高并发、按需收费、备份容灾、日志监控等。</p>\n<h3>二、传统模式和ServerLess模式下项目开发上线流程</h3>\n<p><strong>传统模式</strong></p>\n<p><img src=\"//static.cnodejs.org/FkAKf0N_-FFBJeLkfHAIRIGRaHWB\" alt=\"图片2.png\"></p>\n<p><strong>Serverless模式</strong></p>\n<p><img src=\"//static.cnodejs.org/FujjnTbCFWxsoRWvYvswpvsjvIYQ\" alt=\"图片3.png\"></p>\n<p>Serverless 正在改变未来软件开发的模式和流程\n<img src=\"//static.cnodejs.org/Fo0An9-HSBIKZzNJSYGnPVFmRD4A\" alt=\"图片4.png\"></p>\n<h3>三、Serverless 和ServerFul架构的区别</h3>\n<p><strong>1、传统的ServerFul 架构模式</strong>\nServerFul 架构就是 n 台 Server 通过 网络通信 的 方式 协作在一起，也可以说 ServerFul 架构是基于 Server和 网络通信（分布式计算） 的 软件实现架构 ， Server 可以是 虚拟机 物理机 ，以及基于硬件实现的云的云服务器。\n<img src=\"//static.cnodejs.org/FtT0j6_rKqbHrH016dakycYIanzS\" alt=\"图片5.png\"></p>\n<p><strong>2、Serverless  架构模式</strong></p>\n<p>Serverless 的核心特点就是实现自动弹性伸缩和按量付费。\n<img src=\"//static.cnodejs.org/FnQRSZtlryaZQzuzlosJ0FDO2WxH\" alt=\"图片6.png\"></p>\n<p><strong>相比ServerLes相比ServerFul 有下面一些特点：</strong></p>\n<p><strong>资源分配：</strong> 在 Serverless 架构中，你不用关心应用运行的资源（比如服务配置、磁盘大小）只提供一份代码就行。</p>\n<p><strong>计费方式：</strong> 在 Serverless 架构中，计费方式按实际使用量计费（比如函数调用次数、运行时长），不按传统的执行代码所需的资源计费（比如固定 CPU）。计费粒度也精确到了毫秒级，而不是传统的小时级别。个别云厂商推出了每个月的免费额度，比如腾讯云提供了每个月40万GBs的资源使用额度和100万次调用次数的免费额度。中小企业的网站访问量不是特别大的话完全可以免费使用。</p>\n<p><strong>弹性伸缩</strong>： Serverless 架构的弹性伸缩更自动化、更精确，可以快速根据业务并发扩容更多的实例，甚至允许缩容到零实例状态来实现零费用，对用户来说是完全无感知的。而传统架构对服务器（虚拟机）进行扩容，虚拟机的启动速度也比较慢，需要几分钟甚至更久。</p>\n<p>Serverless相关视频教程：<a href=\"https://www.bilibili.com/video/BV12h411Q7wz?p=2\">https://www.bilibili.com/video/BV12h411Q7wz?p=2</a></p>\n</div>",
      "title": "Serverless今年会火吗？",
      "last_reply_at": "2021-08-01T23:32:24.457Z",
      "good": false,
      "top": false,
      "reply_count": 35,
      "visit_count": 7081,
      "create_at": "2021-04-15T01:40:01.543Z",
      "author": {
        "loginname": "phonegap100",
        "avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
      }
    },
    {
      "id": "60f58c8ae3e67138bc58eacc",
      "author_id": "5a051be2ee9b35da75a869f7",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>hi, all 🙋‍♂️  本篇主要是在上一篇 <a href=\"https://cnodejs.org/topic/60c909ba248d047d8f4ad419\">NodeJs 源码学习笔记</a> 的基础上<s>换了一个帅气的排版与清晰的目录结构</s> <strong>增加了一倍的文章</strong> 🐶 接下来会保持周更的节奏，继续深入学习与讲解 NodeJs 核心模块的实现，感兴趣的大佬们可以 star 🌟 <a href=\"https://github.com/xiaoxiaojx/blog\">github</a> 🌟支持, 谢谢阅读 。</p>\n</blockquote>\n<p><img src=\"https://nodejs.org/static/images/logo-light.svg\" alt></p>\n<p>记录一些 Node.js 相关的学习笔记 📝 , To be continued 🚀</p>\n<h3>Node.js 目录</h3>\n<blockquote>\n<p>Node.js 相关介绍及基础可先阅读 <a href=\"http://nodejs.cn/learn\">官网 Node.js 入门教程</a>, 核心模块的使用及文档可先阅读 <a href=\"http://nodejs.cn/api/\">API 文档 | Node.js 中文网</a></p>\n</blockquote>\n<ol>\n<li>\n<p>运行流程 ( c++, js 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/13\">lib 模块运行</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/14\">c++ 插件运行</a></li>\n</ol>\n</li>\n<li>\n<p>lib 模块 ( js 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/8\">buffer 缓存区</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/7\">cluster 集群</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/10\">stream 可读流</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/11\">stream 可写流</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/12\">stream 双工流、转换流、透传流等</a></li>\n</ol>\n</li>\n<li>\n<p>核心模块 ( c, c++, js 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/4\">微任务</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/9\">llhttp 报文解析</a></li>\n</ol>\n</li>\n<li>\n<p>libuv ( c 源码实现部分 )</p>\n<ol>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/1\">事件循环</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/2\">线程池与i/o</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/3\">子进程与ipc</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/5\">信号</a></li>\n<li><a href=\"https://github.com/xiaoxiaojx/blog/issues/6\">网络与流</a></li>\n</ol>\n</li>\n</ol>\n</div>",
      "title": "深入学习 NodeJs 系列",
      "last_reply_at": "2021-07-31T17:41:14.603Z",
      "good": false,
      "top": false,
      "reply_count": 9,
      "visit_count": 1416,
      "create_at": "2021-07-19T14:30:34.846Z",
      "author": {
        "loginname": "xiaoxiaojx",
        "avatar_url": "https://avatars.githubusercontent.com/u/23253540?v=4&s=120"
      }
    },
    {
      "id": "545249abd0c2f0fe2f533ad6",
      "author_id": "544475344ca29a4d4c08c331",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>rt</p>\n</div>",
      "title": "请教大神们，都怎么实现‘科学上网’撒",
      "last_reply_at": "2021-07-30T08:46:22.538Z",
      "good": false,
      "top": false,
      "reply_count": 27,
      "visit_count": 11096,
      "create_at": "2014-10-30T14:22:35.923Z",
      "author": {
        "loginname": "iamnotblank",
        "avatar_url": "https://avatars1.githubusercontent.com/u/6949176?v=4&s=120"
      }
    },
    {
      "id": "5433d5e4e737cbe96dcef312",
      "author_id": "504c28a2e2b845157708cb61",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>GitHub repo 地址：<a href=\"https://github.com/alsotang/node-lessons\">https://github.com/alsotang/node-lessons</a></p>\n<p>如果大家认为漏了哪些初学者应会的内容，可以在此留言，或者开个 issue 给我（!!推荐）。</p>\n<hr>\n<h1>《Node.js 包教不包会》 – by alsotang</h1>\n<h1>为何写作此课程</h1>\n<p>在 CNode(<a href=\"https://cnodejs.org/\">https://cnodejs.org/</a>) 混了那么久，解答了不少 Node.js 初学者们的问题。回头想想，那些问题所需要的思路都不难，但大部分人由于练手机会少，所以在遇到问题的时候很无措。国内唯一一本排的上号的 Node.js 书是 @朴灵(<a href=\"https://github.com/JacksonTian\">https://github.com/JacksonTian</a>) 的 《深入浅出Node.js》(<a href=\"http://book.douban.com/subject/25768396/\">http://book.douban.com/subject/25768396/</a> )，但这本书离实战还是比较远的。</p>\n<p>这个课程是希望提供更多的 Node.js 实战机会，通过每一节精心安排的课程目标，让 Node.js 的初学者们可以循序渐进地，有目的有挑战地开展 Node.js 的学习。</p>\n<p>更多 Node.js 入门资料请前往：<a href=\"https://cnodejs.org/getstart\">https://cnodejs.org/getstart</a></p>\n<h1>课程列表</h1>\n<ul>\n<li>Lesson 0: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson0\">《搭建 Node.js 开发环境》</a></li>\n<li>Lesson 1: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson1\">《一个最简单的 express 应用》</a></li>\n<li>Lesson 2: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson2\">《学习使用外部模块》</a></li>\n<li>Lesson 3: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson3\">《使用 superagent 与 cheerio 完成简单爬虫》</a></li>\n<li>Lesson 4: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson4\">《使用 eventproxy 控制并发》</a></li>\n<li>Lesson 5: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson5\">《使用 async 控制并发》</a></li>\n<li>Lesson 6: <a href=\"https://github.com/alsotang/node-lessons/tree/master/lesson6\">《测试用例：mocha，should，istanbul》</a></li>\n<li>Lesson 7: 《测试用例：supertest》</li>\n<li>Lesson 8: 《Mongodb 与 Mongoose 的使用》</li>\n<li>Lesson 9: 《一个简单的 blog》</li>\n</ul>\n<h1>License</h1>\n<p>MIT</p>\n</div>",
      "title": "一个面向 Node.js 初学者的系列课程：node-lessons",
      "last_reply_at": "2021-07-29T07:59:46.155Z",
      "good": true,
      "top": false,
      "reply_count": 102,
      "visit_count": 166967,
      "create_at": "2014-10-07T12:00:36.270Z",
      "author": {
        "loginname": "alsotang",
        "avatar_url": "https://avatars.githubusercontent.com/u/1147375?v=4&s=120"
      }
    },
    {
      "id": "60fa8b50e3e671f5de58f30e",
      "author_id": "5a607b3d9288dc8153287f54",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>找不到年份比较新的书籍，有些书是以php为主的，所以前来提问。</p>\n</div>",
      "title": "请问大家开发nodejs微信公众号和前端微信公众号时，如何去入手掌握这些知识的呢",
      "last_reply_at": "2021-07-29T05:34:34.396Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 1035,
      "create_at": "2021-07-23T09:26:40.918Z",
      "author": {
        "loginname": "Choicelin",
        "avatar_url": "https://avatars.githubusercontent.com/u/10152588?v=4&s=120"
      }
    },
    {
      "id": "61023047a5d29d863c2d31dc",
      "author_id": "60e50164ba74605814862a73",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>前言</h2>\n<p>为了进一步提高开发工作效率，最近我们基于 <code>electron</code> 开发了一款媲美 <code>uTools</code> 的开源工具箱 <a href=\"https://github.com/clouDr-f2e/rubick\">rubick</a>。该工具箱不仅仅开源，最重要的是可以使用 <code>uTools</code> 生态内所有开源插件！这将是巨大的能力，意味着 <code>uTools</code> 生态内所有插件可以无差异化使用到  <a href=\"https://github.com/clouDr-f2e/rubick\">rubick</a> 中。</p>\n<p>设计交互上为了更能提高用户的使用效率，我们又尝试去实现了 <code>uTools</code> 中非常优秀的一些设计，比如：<strong>超级面板</strong>。该功能可以通过鼠标快速唤起<code>uTools</code> 插件能力，而不用再打开应用。比如上传图片，只要我们安装了图床插件，那么当鼠标选择桌面上某张图片时，即可快速呼出上传图片的菜单选项，方便省事。接下来一起看看实现方式吧！</p>\n<h3>代码仓库</h3>\n<p><a href=\"https://github.com/clouDr-f2e/rubick\">Rubick github</a></p>\n<h3>功能截图：</h3>\n<h4>文件夹下长按右建</h4>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b3d6ea7a25b4b908acc471471628979~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<h4>选择文件后长按右键</h4>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e220166cb464328b432f42d14ba9ab2~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<h4>选择文字后长按右键</h4>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9f909d08a8441e8a506831796908ef9~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<h2>实现原理</h2>\n<h3>获取选中文案</h3>\n<p>要实现改功能核心是要读取当前用户选中的文案或者文件，根据当前选择内容进行不同功能展示。但是核心有一个问题是如何来实现获取当前选中的内容。这个问题思考了很久很久，要想获取选中的文案，感觉唯一的办法是使用 <code>ctrl + c</code> 或者 <code>command + c</code> 来先复制到剪切板，再通过 <code>electron clipboard</code> 来获取当前剪切板内容。但是 <code>utools</code> 可不是通过先复制再长按这样的操作来实现的，而是直接选中文本或者文件长按后呼起超级面板。<strong>所以一定要在右击长按前获取到当前选中的内容。</strong></p>\n<p>如果要这么干，可能真的无解了，之前就因为这么想，才被无解了。正确的思路应该是先长按再获取选中的内容。别看只是掉了个个，但实现确实天壤之别：</p>\n<ol>\n<li>先获取选中内容：这就要求我们必须监听原生系统选中事件，但是 <code>electron</code> 并没有提供能力，我们也无法监听系统选择事件。</li>\n<li>先右击，后获取内容，这样的好处在于先右击可以通过监听鼠标右击事件，相比选择事件更加容易。</li>\n</ol>\n<p>所以思路就有了，先监听长按右击事件：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; macos\nconst mouseEvents = require(&quot;osx-mouse&quot;);\n\nconst mouseTrack = mouseEvents();\n&#x2F;&#x2F; 按下去的 time\nlet down_time = 0;\n\n&#x2F;&#x2F; 是否弹起\nlet isPress = false;\n\n&#x2F;&#x2F; 监听右击\nmouseTrack.on(&#x27;right-down&#x27;, () =&gt; {\n    isPress = true;\n    down_time = Date.now();\n    &#x2F;&#x2F; 长按 500ms 后触发\n    setTimeout(async () =&gt; {\n      if (isPress) {\n        &#x2F;&#x2F; 获取选中内容\n        const copyResult = await getSelectedText();\n    }, 500);\n})\nmouseTrack.on(&#x27;right-up&#x27;, () =&gt; {\n    isPress = false;\n});\n\n</code></pre><p>接下来一步就是要去实现获取选中内容，要获取选中内容有个比较骚的操作，就是：</p>\n<ol>\n<li>通过 <code>clipboard</code> 先获取当前剪切板内容，并存下 A</li>\n<li>通过 <code>robot.js</code> 来调用系统 <code>command + c</code> 或者 <code>ctrl + c</code></li>\n<li>再通过 <code>clipboard</code> 先获取当前剪切板内容，并存下 B</li>\n<li>再将 A 写到剪切板中，返回 B</li>\n</ol>\n<p>先存剪切板内容的目的在于我们是偷偷帮用户执行了复制动作，当读取完用户选择内容后，需要回复用户之前的剪切板内容。接下来看一下简单的实现：</p>\n<pre class=\"prettyprint language-js\"><code>const getSelected = () =&gt; {\n  return new Promise((resolve) =&gt; {\n    &#x2F;&#x2F; 缓存之前的文案\n    const lastText = clipboard.readText(&#x27;clipboard&#x27;);\n\n    const platform = process.platform;\n    \n    &#x2F;&#x2F; 执行复制动作\n    if (platform === &#x27;darwin&#x27;) {\n      robot.keyTap(&#x27;c&#x27;, &#x27;command&#x27;);\n    } else {\n      robot.keyTap(&#x27;c&#x27;, &#x27;control&#x27;);\n    }\n\n    setTimeout(() =&gt; {\n      &#x2F;&#x2F; 读取剪切板内容\n      const text = clipboard.readText(&#x27;clipboard&#x27;) || &#x27;&#x27;\n      const fileUrl = clipboard.read(&#x27;public.file-url&#x27;);\n      \n      &#x2F;&#x2F; 恢复剪切板内容\n      clipboard.writeText(lastText);\n\n      resolve({\n        text,\n        fileUrl\n      })\n    }, 300);\n  })\n}\n</code></pre><h3>通知超级面板窗口当前选中内容</h3>\n<p>当获取到了选中内容后，接下来就是需要创建超级面板的 <code>BrowserWindow</code>:</p>\n<pre class=\"prettyprint language-js\"><code>const { BrowserWindow, ipcMain, app } = require(&quot;electron&quot;);\n\nmodule.exports = () =&gt; {\n  let win;\n\n  let init = (mainWindow) =&gt; {\n    if (win === null || win === undefined) {\n      createWindow();\n    }\n  };\n\n  let createWindow = () =&gt; {\n    win = new BrowserWindow({\n      frame: false,\n      autoHideMenuBar: true,\n      width: 250,\n      height: 50,\n      show: false,\n      alwaysOnTop: true,\n      webPreferences: {\n        webSecurity: false,\n        enableRemoteModule: true,\n        backgroundThrottling: false,\n        nodeIntegration: true,\n        devTools: false,\n      },\n    });\n    win.loadURL(&#96;file:&#x2F;&#x2F;${__static}&#x2F;plugins&#x2F;superPanel&#x2F;index.html&#96;);\n    win.once(&#x27;ready-to-show&#x27;, () =&gt; win.show());\n    win.on(&quot;closed&quot;, () =&gt; {\n      win = undefined;\n    });\n  };\n\n  let getWindow = () =&gt; win;\n\n  return {\n    init: init,\n    getWindow: getWindow,\n  };\n};\n</code></pre><p>然后再通知 <code>superPanel</code> 进行内容展示：</p>\n<pre class=\"prettyprint language-js\"><code> win.webContents.send(&#x27;trigger-super-panel&#x27;, {\n  ...copyResult,\n  optionPlugin: optionPlugin.plugins,\n});\n</code></pre><h3>超级面板点击操作</h3>\n<p>接下来要实现超级面板点击操作，这块也是比较简单的了，直接上代码好了：</p>\n<h4>1. 打开 Terminal</h4>\n<pre class=\"prettyprint language-js\"><code>const { spawn } = require (&#x27;child_process&#x27;);\n\nspawn(&#x27;open&#x27;, [ &#x27;-a&#x27;, &#x27;Terminal&#x27;, fileUrl ]);\n</code></pre><h4>2. 新建文件</h4>\n<pre class=\"prettyprint language-js\"><code>remote.dialog.showSaveDialog({\n  title: &quot;请选择要保存的文件名&quot;,\n  buttonLabel: &quot;保存&quot;,\n  defaultPath: fileUrl.replace(&#x27;file:&#x2F;&#x2F;&#x27;, &#x27;&#x27;),\n  showsTagField: false,\n  nameFieldLabel: &#x27;&#x27;,\n}).then(result =&gt; {\n  fs.writeFileSync(result.filePath, &#x27;&#x27;);\n});\n</code></pre><h4>3. 复制路径</h4>\n<pre class=\"prettyprint language-js\"><code>clipboard.writeText(fileUrl.replace(&#x27;file:&#x2F;&#x2F;&#x27;, &#x27;&#x27;))\n</code></pre><h2>最后</h2>\n<p>本篇主要介绍如何实现一个类似于 utools 的超级面板功能，当然这远远不是 utools 的全部，下期我们再继续介绍如何实现 utools 其他能力。欢迎大家前往体验 <a href=\"https://github.com/clouDr-f2e/rubick\">Rubick</a> 有问题可以随时提 issue 我们会及时反馈。</p>\n<p>另外，如果觉得设计实现思路对你有用，也欢迎给个 Star：<a href=\"https://github.com/clouDr-f2e/rubick\">https://github.com/clouDr-f2e/rubick</a></p>\n</div>",
      "title": "基于 Electron 实现 uTools 的超级面板",
      "last_reply_at": "2021-07-29T04:36:23.593Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 369,
      "create_at": "2021-07-29T04:36:23.593Z",
      "author": {
        "loginname": "muwoo",
        "avatar_url": "https://avatars.githubusercontent.com/u/21073039?v=4&s=120"
      }
    },
    {
      "id": "61000aaae3e671fbda58fc24",
      "author_id": "5b0bef9657137f22415c46de",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>分析过程：</p>\n<ol>\n<li>服务压测的QPS上不去，通过启动加–prof，拿到CPUprofile，80%是/lib/x86_64-linux-gnu/libc-2.19.so\t导致的，但是，展开后只有0.62是/usr/local/nvm/versions/node/v12.13.1/bin/node\t导致的，没有展示出其他占比比较高的库。</li>\n<li>通过Linux 的perf命令分析，拿到的火焰图没有业务代码，都是底层代码</li>\n</ol>\n<p>是我分析的姿势不对吗？大家有分析过火焰图吗？是怎么分析的？</p>\n</div>",
      "title": "大家有perf拿到的火焰图分析经验吗",
      "last_reply_at": "2021-07-28T06:07:05.406Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 478,
      "create_at": "2021-07-27T13:31:22.211Z",
      "author": {
        "loginname": "LiuWeiMr",
        "avatar_url": "https://avatars.githubusercontent.com/u/17976666?v=4&s=120"
      }
    },
    {
      "id": "6100219ce3e6713f8e58fc77",
      "author_id": "60fce0cae3e671270858f5a9",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>刚看完React的基础视频，实现了PC版的 cNode</p>\n<p>模仿的是知乎的UI</p>\n<p>欢迎点击，欢迎讨论~</p>\n<p><a href=\"https://kongkk.gitee.io\">https://kongkk.gitee.io</a></p>\n<p><a href=\"https://kongkk.gitee.io/\">PC版 cNode</a>\n<img src=\"//static.cnodejs.org/FqNdH3bELle4u1obSXCD8XD-g_JT\" alt=\"image.png\"></p>\n</div>",
      "title": "刚学了React，实现了PC版的 cNode ，欢迎点击，欢迎讨论 ~",
      "last_reply_at": "2021-07-28T04:02:32.866Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 507,
      "create_at": "2021-07-27T15:09:16.563Z",
      "author": {
        "loginname": "kaykong",
        "avatar_url": "https://avatars.githubusercontent.com/u/18086437?v=4&s=120"
      }
    },
    {
      "id": "575c0f3a2ad3c06f1aa3d5ed",
      "author_id": "56cd160ac045c3743304beec",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><ul>\n<li>别用国内付费VPN服务，<strong>Green就是教训</strong>。</li>\n<li>别想着“免费”，能用的付费vpn得花钱，不便宜，<strong>便宜的根本没法用</strong>，几十块一年的等于智商税。</li>\n<li><strong>没有100%稳定高速的服务</strong>，特殊时段，即使付费vpn也不能总是“高速稳定”，别指望一年365天一天24小时随时1080p油管。</li>\n<li>一线国外付费VPN能保证的是“<strong>较好</strong>”的连通率和速度，不完美，但至少能用google，gmail和可接受的油管速度，这仍是目前最好的方案。</li>\n</ul>\n<p><strong>国内还能用支付宝买到</strong>的国外付费vpn推荐：</p>\n<h2><a href=\"https://indx.cc/exp\">ExpressVPN</a></h2>\n<p>全球148+服务器所在地 / 无限流量 / 多协议，包括openVPN / 一键连接 / 同时3台设备 / 256-bit AES加密 / 支付宝支付 / 支持路由器连接 / 完全IP隐藏 / 零日志 / 全终端覆盖 / 30天无条件退款 / Split tunneling技术 + 浏览器插件，同时访问内外网 / <strong>速度相对最快</strong></p>\n<h2><a href=\"https://indx.cc/pandavpn\">熊猫VPN</a></h2>\n<p><code>缺点：运营时间还比较短，只支持同时3个连接，且不支持路由器和Linux，缺乏自动重连等职能功能。</code></p>\n<p>VPN的后起之秀，正在促销，<strong>买一年送一年</strong>，服务器亲测可用，而且很快。产品运营时间还不长，处于推广阶段，价格优惠幅度很大。</p>\n<p>支持Windows，Mac，iOS，Android客户端。连接VPN只需要一个开关即可。界面极其简洁，同时3台设备，这是一个让人惊喜的发现，支持智能分流。</p>\n<p><strong>虽然熊猫VPN远没有ExpressVPN强大，如客户端支持远没有ExpressVPN丰富，同时也只支持3个连接，官方也不披露日志政策</strong>，但对不少人也应该日常够用。从客户端来看，熊猫VPN背后可能不是VPN翻墙技术，而是用了类似SSR的某种加密代理，这无法确定，但是能用最重要。</p>\n<h2><a href=\"https://indx.cc/vyr\">VyprVPN</a></h2>\n<p>70+自有服务器所在地，200,000+IP地址 / 无限流量 / 多协议，独家混淆协议 / 一键连接 / 同时5台设备 / 支持P2P / 变色龙加密，<strong>连接相对最稳定</strong> / 支付宝支付 / 支持路由器连接 / NAT安全机制 / DNS加密 / 全终端覆盖 / 2年款最大优惠 / 30天无条件退款 / 按程序控制网络技术，同时访问内外网</p>\n</div>",
      "title": "稳定的付费vpn推荐",
      "last_reply_at": "2021-07-28T03:25:13.101Z",
      "good": false,
      "top": false,
      "reply_count": 18,
      "visit_count": 17795,
      "create_at": "2016-06-11T13:16:42.992Z",
      "author": {
        "loginname": "flamingtop",
        "avatar_url": "https://avatars3.githubusercontent.com/u/132677?v=4&s=120"
      }
    },
    {
      "id": "605da2e85ac88c2dd115b429",
      "author_id": "5c81f15090c14711cc8cb87e",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>0基础就可以学的nodejs教程，教程包括Nodejs基础，Nodejs手写一个express框架 ，Express使用，Mongodb使用，Mongoose等。</p>\n<p>B站地址：<a href=\"https://www.bilibili.com/video/av38925557/?p=1\">https://www.bilibili.com/video/av38925557/?p=1</a></p>\n<p>视频源码下载地址： <a href=\"https://pan.baidu.com/s/1L5SAAj0sRiX80xBPwMXmxA\">https://pan.baidu.com/s/1L5SAAj0sRiX80xBPwMXmxA</a>    提取码：abcd</p>\n<p>谁说Nodejs每人学我和谁急眼</p>\n<p><strong>教程包括：</strong></p>\n<p>其中包括Nodejs安装配置、Nodejs内置模块、Nodejs自定义模块、Nodejs第三方模块、npm包管理、Nodejs新特性 async await 、以及Nodejs创建web服务、模板引擎、NodeJs封装一个自己的Express框架、MongoDB安装、MongoDB增删改查、MongoDB索引、MongoDB权限管理、MongoDB聚合管道、MongoDB aggregate聚合管道 多表关联查询、Nodejs操作mongodb数据库、Express介绍、Express路由、Express Ejs 、Express Cookie、Express Session、Express Restfull APi、Express 上传图片、 Mongoose的安装、mongoose增删改查、mongoose默认参数 、mongoose模块化、Mongoose 预定义模式修饰符、自定义修饰符、Mongoose索引、扩展Mongoose内置查询方法、Mongoose 数据校验、Mongoose两个表关联查询aggregate、MongooseN个表关联查询aggregate、Mongoose、 DBRef  Populate、以及Express+Mongoose实战</p>\n</div>",
      "title": "20万人在学的Nodejs+Express+mongoose教程-B站免费看 源码免费下 谁说Node不火",
      "last_reply_at": "2021-07-28T00:56:01.407Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 5600,
      "create_at": "2021-03-26T09:01:28.364Z",
      "author": {
        "loginname": "phonegap100",
        "avatar_url": "https://avatars.githubusercontent.com/u/5773766?v=4&s=120"
      }
    },
    {
      "id": "60e3d580ba746017a3862726",
      "author_id": "5ea15a200275394e76882cdd",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>Dart Flutter目前很火吗? B站上看见一个Flutter的教程都有60多万播放量了。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1S4411E7LY?p=1\">https://www.bilibili.com/video/BV1S4411E7LY?p=1</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1S4411E7LY?p=16\">https://www.bilibili.com/video/BV1S4411E7LY?p=16</a></p>\n<p>我就想知道 前端有没有必要学Flutter?</p>\n</div>",
      "title": "Dart Flutter目前很火吗? --前端有没有必要学Flutter",
      "last_reply_at": "2021-07-28T00:47:43.735Z",
      "good": false,
      "top": false,
      "reply_count": 12,
      "visit_count": 2770,
      "create_at": "2021-07-06T04:01:04.803Z",
      "author": {
        "loginname": "wuwangju0",
        "avatar_url": "https://avatars.githubusercontent.com/u/64194964?v=4&s=120"
      }
    },
    {
      "id": "6100141ce3e671787158fc3f",
      "author_id": "610013c7e3e671064a58fc3a",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>以前碰到过这问题，当时还没来这个论坛，一直在用express，现在想搞清这个问题</p>\n</div>",
      "title": "Node.js Koa session对应的Cookie可以被解密的问题",
      "last_reply_at": "2021-07-27T14:11:40.028Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 326,
      "create_at": "2021-07-27T14:11:40.028Z",
      "author": {
        "loginname": "Codexiaowu",
        "avatar_url": "https://avatars.githubusercontent.com/u/53120871?v=4&s=120"
      }
    },
    {
      "id": "60e25b8cba74602248862373",
      "author_id": "5ea15a200275394e76882cdd",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>同上,各位老铁 Nestjs很火吗?为什么Star量以及每周下载量如此之高,这个框架国内用的多吗?</p>\n<p><img src=\"//static.cnodejs.org/FlKGhyRfHXLrr6bUlreNJUEF6U65\" alt=\"nestjs.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FoYcKcGW5iRUnxoPryjmqyrzRWcI\" alt=\"nest1.jpg\"></p>\n<p>同上,各位老铁 Nestjs很火吗?为什么Star量以及每周下载量如此之高,这个框架国内用的多吗?</p>\n</div>",
      "title": "Nestjs很火吗?为什么Star量以及每周下载量如此之高",
      "last_reply_at": "2021-07-27T11:50:53.846Z",
      "good": false,
      "top": false,
      "reply_count": 16,
      "visit_count": 4583,
      "create_at": "2021-07-05T01:08:28.824Z",
      "author": {
        "loginname": "wuwangju0",
        "avatar_url": "https://avatars.githubusercontent.com/u/64194964?v=4&s=120"
      }
    },
    {
      "id": "60fcd66ee3e671acb558f58f",
      "author_id": "60fcd4b7e3e67108e258f57a",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/Fk_pD39ZUydXqajy415-hXOoeDfA\" alt=\"444444444.png\">\n<img src=\"//static.cnodejs.org/FodavimNjSw_jIIxUHEOmZGZFrdl\" alt=\"33333333333333.png\">\n刚刚才开始学，想搭个路由，通过浏览器访问http://localhost/home 报404，请问老师这是什么原因呢。</p>\n</div>",
      "title": "求问：匹配路由不能访问locahost。",
      "last_reply_at": "2021-07-27T02:38:37.274Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 959,
      "create_at": "2021-07-25T03:11:42.124Z",
      "author": {
        "loginname": "Hit1me",
        "avatar_url": "https://avatars.githubusercontent.com/u/30171759?v=4&s=120"
      }
    },
    {
      "id": "60ff7098e3e671563158fa34",
      "author_id": "545870576537f4d52c414eb6",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h3>网上搜个PPT模板，全是 tm套路 ，一点下载就让注册，一注册就让付钱，gun！</h3>\n<h3>老子自己做个无注册直接下载的纯白嫖的！</h3>\n<p>网址如下：</p>\n<h1><a href=\"http://gitppt.com\">gitppt.com</a></h1>\n<h4>但资源托管在 <a href=\"http://raw.githubusercontent.com\">raw.githubusercontent.com</a>，国内部分区域因dns问题恐怕无法加载图片和ppt文件。大家凑合用吧。</h4>\n<p><img src=\"//static.cnodejs.org/FpYiqOLEQChiArFGMLgnnjJ1r0yx\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FoYHGSLwy0BvzD49deNaK08j7_rA\" alt=\"image.png\">\n<img src=\"//static.cnodejs.org/FtjzxxVDFbGpZnlSAeK6yZ5ESx2m\" alt=\"image.png\"></p>\n</div>",
      "title": "写几行简单js撸了个程序员专用白嫖PPT模板网站：gitppt.com （大家快来白嫖）",
      "last_reply_at": "2021-07-27T02:34:00.255Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 413,
      "create_at": "2021-07-27T02:34:00.255Z",
      "author": {
        "loginname": "pangguoming",
        "avatar_url": "https://avatars.githubusercontent.com/u/7269202?v=4&s=120"
      }
    },
    {
      "id": "60f8e83be3e671299858ef9a",
      "author_id": "5b0bef9657137f22415c46de",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>最近项目被俩次质疑了一个问题，就是后端服务是go写的，前端用node+react，node做go服务接口请求拿到数据和html渲染整合，下发到客户端这样的模式。但是，为什么用node，不直接用react写页面就好了吗？\n我的点主要是解决技术问题：</p>\n<ol>\n<li>node对于ssr有很好的技术支持，使用就很方便</li>\n<li>页面有多个请求，放在react就很重，在node层做聚合降低复杂性。</li>\n</ol>\n<p>被质疑的点：</p>\n<ol>\n<li>node作为中间层瓶颈就放在node端了，多加一层收益小，影响大</li>\n<li>node的稳定性和go差距很大，容易出事故\n面对这个质疑大家有什么看法吗？</li>\n</ol>\n</div>",
      "title": "如何回复为什么用Node作为大前端，用前端直接请求后端不就好了吗",
      "last_reply_at": "2021-07-26T11:43:30.647Z",
      "good": false,
      "top": false,
      "reply_count": 14,
      "visit_count": 1566,
      "create_at": "2021-07-22T03:38:35.531Z",
      "author": {
        "loginname": "LiuWeiMr",
        "avatar_url": "https://avatars.githubusercontent.com/u/17976666?v=4&s=120"
      }
    },
    {
      "id": "60fa9be1e3e671144f58f359",
      "author_id": "5504014773263b0e4eef9c50",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>们目前项目中的代码专门针对程序的边界做了一层封装，尤其是调用第三方应用的请求相关的代码。但是我感觉不是特别的好，且看下面这一段伪代码</p>\n<ul>\n<li>类的定义</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>const axios = require(&#x27;axios&#x27;);\n\nclass Client {\n  constructor({ url, username, password }) {\n    this.url = url;\n\tthis.username = username;\n\tthis.password = password;\n\tthis.token = &#x27;&#x27;;\n\t\n\tthis.login = this.login.bind(this);\n\tthis.getSomething = this.getSomething.bind(this);\n\t\n\tthis.login();\n  }\n  \n  async login() {\n    const { token } = await axios.post(...);\n\tthis.token = token;\n  }\n  \n  async getSomething(params) {\n    if (!this.token) {\n\t  console.error(&#x27;未登录&#x27;);\n\t  return;\n\t}\n\t\n    const result = await axios.get(..., {\n\t  headers: {\n\t    token: this.token,\n\t  },\n\t  ...\n\t});\n\t\n\treturn result;\n  }\n}\n</code></pre><ul>\n<li>调用</li>\n</ul>\n<pre class=\"prettyprint language-js\"><code>const Client = require(&#x27;.&#x2F;Client.js&#x27;);\n\nasync main() {\n  const client = new Client({\n    url: &#x27;127.0.0.1&#x27;,\n\tusername: &#x27;zhangsan&#x27;,\n\tpassword: &#x27;...&#x27;\n  });\n  \n  const result = await client.getSomething();\n  \n  console.log(result);\n}\n</code></pre><p>他这里在实例化该对象是，构造函数调用了一个<code>async</code>的函数，如果立即调用<code>getSomething()</code>方法，可能会存在<code>login()</code>方法还未执行完，<code>token</code>还没有的情况。\n请问一下大家一般是怎样封装这样的类的？或者说怎样处理这样的情况？</p>\n</div>",
      "title": "请求方客户端代码的封装方式，请教一下大家",
      "last_reply_at": "2021-07-26T09:09:38.755Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 844,
      "create_at": "2021-07-23T10:37:21.371Z",
      "author": {
        "loginname": "helloMane",
        "avatar_url": "https://avatars.githubusercontent.com/u/10976717?v=4&s=120"
      }
    },
    {
      "id": "60fce71ae3e671758e58f5b5",
      "author_id": "5477d58565e5a201268b928c",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>ts-json-model</h1>\n<p>在<code>Typescript</code>开发过程中，不可避免要编写<code>Model</code>；对于<code>Model</code>不多的简单应用倒是没有什么，但是对于复杂且<code>Model</code>较多、较复杂的应用，\n编写<code>Model</code>就变成了枯燥、繁琐的体力话；该工具就是为了解决找个问题而生；当然前提指需要提供对应Model的<code>json</code>文件即可。</p>\n<h2>安装</h2>\n<pre class=\"prettyprint\"><code>$ npm install -g ts-json-model\n</code></pre><h2>使用</h2>\n<p>输出当前版本</p>\n<pre class=\"prettyprint\"><code>$ j2m --v\n</code></pre><p>工具默认提供命令行是<code>j2m</code>，默认的工作目录是当前目录下的<code>./src/json</code>，\n输出目录是<code>./src/model</code>，当然也可以提供配置文件的形式覆盖默认的配置，文件名称是\n<code>j2m.config.json</code>，配置如下：</p>\n<pre class=\"prettyprint language-json\"><code>{\n  &quot;src&quot;: &quot;.&#x2F;src&#x2F;json&quot;,\n  &quot;output&quot;: &quot;.&#x2F;src&#x2F;model&quot;\n}\n</code></pre><h3>关键字</h3>\n<ul>\n<li><code>_extend</code>:表示要继承的类，如果不存在，那么新建一个空的类。</li>\n<li><code>_name</code>: 当前对象类的名称。</li>\n<li><code>$</code>: ‘自定义类名’，如果不存在活创建一个空的类。</li>\n<li><code>#{content}#</code>: 字段/属性的注释</li>\n</ul>\n<p>接下来运行</p>\n<pre class=\"prettyprint\"><code>$ j2m\n</code></pre><h2>demo</h2>\n<p>接下来以模块提供的example为例，讲解如何使用：</p>\n<p>目录结构：</p>\n<p><img src=\"http://static.94-me.com/images/2021/07/1.jpg\" alt=\"image\"></p>\n<p>运行</p>\n<pre class=\"prettyprint\"><code>npm run j2m\n</code></pre><p>过程</p>\n<p><img src=\"http://static.94-me.com/images/2021/07/2.jpg\" alt=\"image\"></p>\n<p>结果</p>\n<p><img src=\"http://static.94-me.com/images/2021/07/3.jpg\" alt=\"image\"></p>\n<p>介绍完毕，收工！</p>\n</div>",
      "title": "Typescript的json转model工具介绍",
      "last_reply_at": "2021-07-25T04:22:50.247Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 783,
      "create_at": "2021-07-25T04:22:50.247Z",
      "author": {
        "loginname": "ljl0612",
        "avatar_url": "https://avatars.githubusercontent.com/u/8716954?v=4&s=120"
      }
    },
    {
      "id": "60f53d15e3e6713cb958e9fc",
      "author_id": "5f4f20c268156574e6e6df32",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>async function test2() {\n    test();\n    await test();\n}\n\nfunction test() {\n    &#x2F;&#x2F; I want to know if this is called by await ...\n}\n</code></pre></div>",
      "title": "如何知道函数被调用时是否是 await 调用？",
      "last_reply_at": "2021-07-23T20:05:56.951Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 1317,
      "create_at": "2021-07-19T08:51:33.985Z",
      "author": {
        "loginname": "ahuangege",
        "avatar_url": "https://avatars.githubusercontent.com/u/28346577?v=4&s=120"
      }
    },
    {
      "id": "60f9be26e3e671009f58f149",
      "author_id": "5c1ea9e976c4964062a1ca15",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>前言：今天下载了Node.js最新版代码，并为Node.js的TCP模块增加了SO_RESUEPORT的能力，本文介绍一下具体的实现，关于SO_RESUEPORT的知识可以参考之前的文章或者网上文章。</p>\n<h1>1 Libuv</h1>\n<p>SO_RESUEPORT是操作系统内核提供的能力，所以第一步首先修改Libuv。考虑到操作系统兼容性的问题，目前只支持Linux系统，旧版Mac OS也支持相关属性但是效果不符合预期，新版Mac OS倒是支持，考虑到Node.js在几乎都是部署到Linux，所以可以先关注Linux内核。首先修改deps/uv/include/uv.h。</p>\n<pre class=\"prettyprint language-c\"><code>enum uv_tcp_flags {\n  UV_TCP_IPV6ONLY = 1,\n  &#x2F;&#x2F; 支持SO_RESUEPORT flags\n  UV_TCP_REUSEPORT = 2\n};\n</code></pre><p>接着修改deps/uv/src/unix/tcp.c。</p>\n<pre class=\"prettyprint language-c\"><code> #if defined(SO_REUSEPORT) &amp;&amp; defined(__linux__) \n    on = 1;\n    if ((flags &amp; UV_TCP_REUSEPORT) &amp;&amp; setsockopt(tcp-&gt;io_watcher.fd, SOL_SOCKET, SO_REUSEPORT, &amp;on, sizeof(on)))\n      return UV__ERR(errno);\n  #endif\n</code></pre><p>这里判断一下是否有两个宏，有的话才能使用SO_RESUEPORT。如果支持则通过setsockopt设置socket的SO_REUSEPORT标记，这是最核心的逻辑。</p>\n<h1>2 修改C++层</h1>\n<p>修改完底层的Libuv后，继续修改C++层，因为这是一个可选的属性，所以我们需要增加相关的逻辑。修改src/tcp_wrap.cc。首先导出一个新的常量</p>\n<pre class=\"prettyprint language-c\"><code>#if defined(SO_REUSEPORT) &amp;&amp; defined(__linux__) \n NODE_DEFINE_CONSTANT(constants, UV_TCP_REUSEPORT);\n#endif\n</code></pre><p>在JS层可以通过判断是否导出了这个常量来判断系统是否支持SO_RESUEPORT。接着修改bind函数，因为我们再bind的时候可以设置SO_RESUEPORT。</p>\n<pre class=\"prettyprint language-c\"><code>template &lt;typename T&gt;\nvoid TCPWrap::Bind(\n    const FunctionCallbackInfo&lt;Value&gt;&amp; args,\n    int family,\n    std::function&lt;int(const char* ip_address, int port, T* addr)&gt; uv_ip_addr) {\n  TCPWrap* wrap;\n  ASSIGN_OR_RETURN_UNWRAP(&amp;wrap,\n                          args.Holder(),\n                          args.GetReturnValue().Set(UV_EBADF));\n  Environment* env = wrap-&gt;env();\n  node::Utf8Value ip_address(env-&gt;isolate(), args[0]);\n  int port;\n  unsigned int flags = 0;\n  if (!args[1]-&gt;Int32Value(env-&gt;context()).To(&amp;port)) return;\n  &#x2F;&#x2F; ipv6支持ipv6Only和SO_RESUEPORT\n  if (family == AF_INET6 &amp;&amp;\n      !args[2]-&gt;Uint32Value(env-&gt;context()).To(&amp;flags)) {\n    return;\n  &#x2F;&#x2F; ipv4之前是不支持任何标记的，这里需要加上这个逻辑，因为我们需要支持SO_RESUEPORT\n  } else if (family == AF_INET4 &amp;&amp;\n      !args[2]-&gt;Uint32Value(env-&gt;context()).To(&amp;flags)) {\n    return;\n  }\n\n  T addr;\n  int err = uv_ip_addr(*ip_address, port, &amp;addr);\n\n  if (err == 0) {\n    err = uv_tcp_bind(&amp;wrap-&gt;handle_,\n                      reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr),\n                      flags);\n  }\n  args.GetReturnValue().Set(err);\n}\n</code></pre><p>C++主要是完成透传flags的逻辑。</p>\n<h1>3 修改JS层</h1>\n<p>修改JS层是最复杂的地方，主要是为了应用层的兼容性问题。也就是说如果Node.js真的支持了SO_RESUEPORT，在某些平台不支持SO_RESUEPORT的情况下，我们如何能保证我们的代码能在各个平台上跑。简单来说，如果我们平台支持SO_RESUEPORT，我们可以开启多个子进程，然后分别执行以下代码。</p>\n<pre class=\"prettyprint language-c\"><code>const http = require(&#x27;http&#x27;);\nhttp.createServer((req, res) =&gt; {\n    res.end(&#x27;hello&#x27;);\n}).listen({port: 8000， reuseport: true});\n</code></pre><p>这时候，只需要修改一下Node.js的net.js，把reuseport标记传到C++层再传到Libuv就行，但是问题是，如果我们这样写代码，就无法在不支持SO_RESUEPORT的平台跑了，因为会导致重复监听端口的错误。所以为了兼容性，我想的方案是利用Cluster模块，目前Cluster模块支持轮询和共享两种模式，那么我们再加一种reuseport模式就好了，这样的好处是一旦我们平台不支持SO_RESUEPORT，我们可以降级到Node.js现在到模式。我们知道Cluster模块的原理有两种，一种是主进程监听，分发连接给子进程，另一种是主进程创建socket，通过文件描述符传递的方式传给子进程，所有的进程都是共享一个socket的。下面我们看看怎么做。首先修改lib/internal/cluster/primary.js。</p>\n<pre class=\"prettyprint language-c\"><code>\t&#x2F;&#x2F; 增加这if的逻辑\n   if ((message.addressType === 4 || \n\tmessage.addressType === 6) &amp;&amp; \n\t(message.flags &amp; TCPConstants.UV_TCP_REUSEPORT)) {\n\thandle = new ReusePort(key, address, message);\n   } else if (schedulingPolicy !== SCHED_RR ||\n       message.addressType === &#x27;udp4&#x27; ||\n       message.addressType === &#x27;udp6&#x27;) {\n     handle = new SharedHandle(key, address, message);\n   } else {\n     handle = new RoundRobinHandle(key, address, message);\n   }\n</code></pre><p>我们在queryServer函数里增加了一个if的逻辑。如果addressType是4或6说明是TCP协议，并且设置了UV_TCP_REUSEPORT（listen的时候传入），就会走到reuseport的逻辑，剩下的两个else是目前Node.js的逻辑。我们看看ReusePort.js做了什么。</p>\n<pre class=\"prettyprint language-c\"><code>&#x27;use strict&#x27;;\nconst assert = require(&#x27;internal&#x2F;assert&#x27;);\nconst net = require(&#x27;net&#x27;);\nconst { constants: TCPConstants } = internalBinding(&#x27;tcp_wrap&#x27;);\n\nmodule.exports = ReusePort;\n\nfunction ReusePort(key, address, {port, addressType, fd, flags}) {\n  this.key = key;\n  this.workers = [];\n  this.handles = [];\n  this.list = [address, port, addressType, fd, flags];\n}\n\nReusePort.prototype.add = function(worker, send) {\n  assert(!this.workers.includes(worker));\n  const rval = net._createServerHandle(...this.list);\n  let errno;\n  let handle;\n  if (typeof rval === &#x27;number&#x27;)\n    errno = rval;\n  else\n    handle = rval;\n  this.workers.push(worker);\n  this.handles.push(handle);\n  send(errno, null, handle);\n};\n\nReusePort.prototype.remove = function(worker) {\n  const index = this.workers.indexOf(worker);\n\n  if (index === -1)\n    return false; &#x2F;&#x2F; The worker wasn&#x27;t sharing this handle.\n\n  this.workers.splice(index, 1);\n  this.handles[index].close();\n  this.handles.splice(index, 1);\n  return true;\n};\n\n</code></pre><p>上面的代码我们只需要关注net._createServerHandle。在不能多个进程同时监听同一个端口的情况下，Node.js只会调net._createServerHandle创建一个socket，然后多个进程共享。而我们这里会给每个进程创建一个socket。这个socket就是在子进程调用queryServer的时候返回给子进程的。剩下的逻辑我们暂时不用关注。最后看一下_createServerHandle的逻辑。</p>\n<pre class=\"prettyprint language-c\"><code>const handle = new TCP(TCPConstants.SERVER);\nif (addressType === 6) {\n  err = handle.bind6(address, port, flags);\n} else {\n  err = handle.bind(address, port, flags || 0);\n}\n</code></pre><p>_createServerHandle的逻辑是创建一个socket并且给socket绑定IP和端口，我们看到这里会给C++层传入flags，C++层就会传到LIbuv了，这样我们就完成了整个过程，整体的流程如下。\n1 子进程执行listen的时候，传入reuseport为true\n2 子进程通过进程间通信请求主进程\n3 主进程返回一个新的socket并绑定到对应的地址\n4 子进程执行listen启动服务器。</p>\n<h1>4 使用</h1>\n<p>接下来我们看看如何使用，首先创建一个server.js。</p>\n<pre class=\"prettyprint language-c\"><code>const cluster = require(&#x27;cluster&#x27;);\nconst os = require(&#x27;os&#x27;);\nconst http = require(&#x27;http&#x27;);\nconst cpus = os.cpus().length;\n\nif (cluster.isPrimary) {\n  const map = {};\n  for (let i = 0; i &lt; cpus; i++) {\n    const worker = cluster.fork();\n    map[worker.process.pid] = 0;\n    worker.on(&#x27;message&#x27;, (pid) =&gt; {\n        map[pid]++;\n    });\n  }\n\n  process.on(&#x27;SIGINT&#x27;, () =&gt; {\n    console.log(map);\n  });\n} else {\n  http.createServer((req, res) =&gt; {\n      process.send(process.pid);\n      res.end(&#x27;hello&#x27;);\n  }).listen({reuseport: true, port: 8000});\n}\n</code></pre><p>再创建一个客户端client.js</p>\n<pre class=\"prettyprint language-c\"><code>const http = require(&#x27;http&#x27;);\nfunction connect() {\n    setTimeout(() =&gt; {\n        http.get(&#x27;http:&#x2F;&#x2F;localhost:8000&#x2F;&#x27;, (res) =&gt; {\n            console.log(res.statusCode);\n            connect();\n        });\n    }, 50);\n}\nconnect();\n</code></pre><p>客户端串行访问服务器，我们看到使用方式和目前Node.js的Cluster使用一样。即使我们把reuseport改成false或者其他平台跑也没问题，效果如下\n<img src=\"https://img-blog.csdnimg.cn/9e0c8ad5197a4c80a51fdd6e3c2d454f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\">\n我们看到在reuseport的情况下，负载还是挺均衡的。</p>\n<p>后记：目前是通过listen的时候传入参数去控制是否开启SO_RESUEPORT的，后续可以增加通过设置cluster.schedulingPolicy的方式，和目前共享、轮询模式对齐，考虑到Cluster模块不是必须，因为我们可以直接用子进程模块监听同一个端口。所以通过listen函数去控制是非常必要的。目前通过修改Node.js内核大概体验了一下SO_RESUEPORT，后续review和改进一下代码。有兴趣的同学可以参考和编译运行，如果你有想法欢迎交流。\n仓库：<a href=\"https://github.com/theanarkh/node%E7%9A%84add-reuseport\">https://github.com/theanarkh/node的add-reuseport</a> 分支\n改动：<a href=\"https://github.com/theanarkh/node/pull/1\">https://github.com/theanarkh/node/pull/1</a>\nLibuv pr：<a href=\"https://github.com/libuv/libuv/pull/3198\">https://github.com/libuv/libuv/pull/3198</a></p>\n<p>更多阅读：\n1 <a href=\"https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/\">Socket Sharding in NGINX Release 1.9.1</a>\n2 <a href=\"https://zhuanlan.zhihu.com/p/384355624\">提升Node.js性能之SO_REUSEPORT的探讨</a>\n3 <a href=\"https://mp.weixin.qq.com/s?__biz=MzUyNDE2OTAwNw==&amp;mid=2247485469&amp;idx=1&amp;sn=b9fcbed38f691ab3fca2e2d32cc6c07d&amp;chksm=fa30325dcd47bb4bdb33298d881fa10668bb521da96f9f16eb83bb00e36c6d2269d0fa16cfe1&amp;token=660197072&amp;lang=zh_CN#rd\">从内核看SO_REUSEPORT的实现（基于5.9.9）</a>\n4 <a href=\"https://zhuanlan.zhihu.com/p/371836188\">服务器处理连接的架构演变</a>\n5 <a href=\"https://lwn.net/Articles/542629/\">The SO_REUSEPORT socket option</a>\n6 <a href=\"https://lwn.net/Articles/542728/\">soreuseport: UDP/IPv4 implementation</a>\n7 <a href=\"https://man7.org/linux/man-pages/man7/socket.7.html\">SO_REUSEPORT内核文档</a></p>\n</div>",
      "title": "在Node.js中使用SO_RESUEPORT",
      "last_reply_at": "2021-07-23T09:53:47.591Z",
      "good": false,
      "top": false,
      "reply_count": 9,
      "visit_count": 843,
      "create_at": "2021-07-22T18:51:18.691Z",
      "author": {
        "loginname": "theanarkh",
        "avatar_url": "https://avatars.githubusercontent.com/u/21155906?v=4&s=120"
      }
    },
    {
      "id": "60fa8009e3e671477d58f2db",
      "author_id": "5f322c8a2799ce64a0aabac9",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"https://content.markdowner.net/pub/G5q2k7-Rm2vv9D\" alt></p>\n<p><a href=\"https://markdowner.net/article/203966476594446336\">黑客说：如何做到 4 天上线一个小程序？</a></p>\n</div>",
      "title": "黑客说：如何做到 4 天上线一个小程序？",
      "last_reply_at": "2021-07-23T08:38:33.425Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 862,
      "create_at": "2021-07-23T08:38:33.425Z",
      "author": {
        "loginname": "Q-Qplus1s",
        "avatar_url": "https://avatars.githubusercontent.com/u/50064165?v=4&s=120"
      }
    },
    {
      "id": "55b9e875f36f579657fc52f3",
      "author_id": "530ed7b25adfcd9c0f0713b6",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>在团队合作中，你写好了一个函数，供队友使用，跑去跟你的队友说，你传个A值进去，他就会返回B结果了。过了一会，你队友跑过来说，我传个A值却返回C结果，怎么回事？你丫的有没有测试过啊？</p>\n<p>大家一起写个项目，难免会有我要写的函数里面依赖别人的函数，但是这个函数到底值不值得信赖？单元测试是衡量代码质量的一重要标准，纵观Github的受欢迎项目，都是有test文件夹，并且buliding-pass的。如果你也为社区贡献过module，想更多人使用的话，加上单元测试吧，让你的module值得别人信赖。</p>\n<p>要在Nodejs中写单元测试的话，你需要知道用什么测试框架，怎么测试异步函数，怎么测试私有方法，怎么模拟测试环境，怎么测试依赖HTTP协议的web应用，需要了解TDD和BDD，还有需要提供测试的覆盖率。</p>\n<blockquote>\n<p>本文的示例代码会备份到 Github : <a href=\"https://github.com/JerryC8080/unittest-demo\">unittest-demo</a></p>\n</blockquote>\n<h2>目录</h2>\n<ol>\n<li>测试框架</li>\n<li>断言库</li>\n<li>需求变更</li>\n<li>异步测试</li>\n<li>异常测试</li>\n<li>测试私有方法</li>\n<li>测试Web应用</li>\n<li>覆盖率</li>\n<li>使用Makefile把测试串起来</li>\n<li>持续集成，Travis-cli</li>\n<li>一些观点</li>\n<li>彩蛋</li>\n<li>整理</li>\n</ol>\n<h2>测试框架</h2>\n<p>Nodejs的测试框架还用说？大家都在用，Mocha。</p>\n<p>Mocha 是一个功能丰富的Javascript测试框架，它能运行在Node.js和浏览器中，支持<strong>BDD</strong>、<strong>TDD</strong>、<strong>QUnit</strong>、<strong>Exports</strong>式的测试，本文主要示例是使用更接近与思考方式的BDD，\b如果了解更多可以访问Mocha的<a href=\"http://mochajs.org/\">官网</a></p>\n<h4>\b</h4>\n<h4>测试接口</h4>\n<p>Mocha的BDD接口有：</p>\n<ul>\n<li><code>describe()</code></li>\n<li><code>it()</code></li>\n<li><code>before()</code></li>\n<li><code>after()</code></li>\n<li><code>beforeEach()</code></li>\n<li><code>afterEach()</code></li>\n</ul>\n<h4>安装</h4>\n<p><code>npm install mocha -g</code></p>\n<h4>编写一个稳定可靠的模块</h4>\n<p>模块具备limit方法，输入一个数值，小于0的时候返回0，其余正常返回</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.limit = function (num) {\n  if (num &lt; 0) {\n    return 0;\n  }\n  return num;\n};\n</code></pre><h4>目录分配</h4>\n<ul>\n<li><code>lib</code>，存放模块代码的地方</li>\n<li><code>test</code>，存放单元测试代码的地方</li>\n<li><code>index.js</code>，向外导出模块的地方</li>\n<li><code>package.json</code>，包描述文件</li>\n</ul>\n<h4>测试</h4>\n<pre class=\"prettyprint language- javascript\"><code>var lib = require(&#x27;index&#x27;);\n\ndescribe(&#x27;module&#x27;, function () {\n  describe(&#x27;limit&#x27;, function () {\n    it(&#x27;limit should success&#x27;, function () {\n      lib.limit(10);\n    });\n  });\n});\n</code></pre><h4>结果</h4>\n<p>在当前目录下执行<code>mocha</code>：</p>\n<pre class=\"prettyprint language-\"><code>$ mocha\n\n  ․\n\n  ✔ 1 test complete (2ms)\n</code></pre><h2>断言库</h2>\n<p>上面的代码只是运行了代码，并没有对结果进行检查，这时候就要用到断言库了，Node.js中常用的断言库有：</p>\n<ul>\n<li>should.js</li>\n<li>expect.js</li>\n<li>chai</li>\n</ul>\n<h4>加上断言</h4>\n<p>使用<code>should</code>库为测试用例加上断言</p>\n<pre class=\"prettyprint language- javascript\"><code>it(&#x27;limit should success&#x27;, function () {\n  lib.limit(10).should.be.equal(10);\n});\n</code></pre><h2>\b需求变更</h2>\n<p>需求变更啦： <code>limit</code>这个方法还要求返回值大于100时返回100。</p>\n<p>针对需求重构代码之后，正是测试用例的价值所在了，</p>\n<p>它能确保你的改动对原有成果没有造成破坏。</p>\n<p>但是，你要多做的一些工作的是，需要为新的需求编写新的测试代码。</p>\n<h2>异步测试</h2>\n<h4>测试异步回调</h4>\n<p>lib库中新增async函数：</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.async = function (callback) {\n  setTimeout(function () {\n    callback(10);\n  }, 10);\n};\t\n</code></pre><p>测试异步代码：</p>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;async&#x27;, function () {\n  it(&#x27;async&#x27;, function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n</code></pre><h4>测试Promise</h4>\n<p>使用should提供的Promise断言接口:</p>\n<ul>\n<li><code>finally</code> | <code>eventually</code></li>\n<li><code>fulfilled</code></li>\n<li><code>fulfilledWith</code></li>\n<li><code>rejected</code></li>\n<li><code>rejectedWith</code></li>\n<li><code>then</code></li>\n</ul>\n<p>测试代码</p>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;should&#x27;, function () {\n  describe(&#x27;#Promise&#x27;, function () {\n    it(&#x27;should.reject&#x27;, function () {\n      (new Promise(function (resolve, reject) {\n        reject(new Error(&#x27;wrong&#x27;));\n      })).should.be.rejectedWith(&#x27;wrong&#x27;);\n    });\n\n    it(&#x27;should.fulfilled&#x27;, function () {\n      (new Promise(function (resolve, reject) {\n        resolve({username: &#x27;jc&#x27;, age: 18, gender: &#x27;male&#x27;})\n      })).should.be.fulfilled().then(function (it) {\n          it.should.have.property(&#x27;username&#x27;, &#x27;jc&#x27;);\n        })\n    });\n  });\n});\n</code></pre><h4>异步方法的超时支持</h4>\n<p>Mocha的超时设定默认是2s，如果执行的测试超过2s的话，就会报timeout错误。</p>\n<p>可以主动修改超时时间，有两种方法。</p>\n<h4>命令行式</h4>\n<p><code>mocha -t 10000</code></p>\n<h4>API式</h4>\n<pre class=\"prettyprint language- javascript\"><code>describe(&#x27;async&#x27;, function () {\n  this.timeout(10000);\n  it(&#x27;async&#x27;, function (done) {\n    lib.async(function (result) {\n      done();\n    });\n  });\n});\n</code></pre><p>这样的话<code>async</code>执行时间不超过10s，就不会报错timeout错误了。</p>\n<h2>异常测试</h2>\n<p>异常应该怎么测试，现在有<code>getContent</code>方法，他会读取指定文件的内容，但是不一定会成功，会抛出异常。</p>\n<pre class=\"prettyprint language- javascript\"><code>exports.getContent = function (filename, callback) {\n  fs.readFile(filename, &#x27;utf-8&#x27;, callback);\n};\n</code></pre><p>这时候就应该模拟(mock)错误环境了</p>\n<h4>简单Mock</h4>\n<pre class=\"prettyprint language- javascript\"><code>describe(&quot;getContent&quot;, function () {\n  var _readFile;\n  before(function () {\n    _readFile = fs.readFile;\n    fs.readFile = function (filename, encoding, callback) {\n      process.nextTick(function () {\n        callback(new Error(&quot;mock readFile error&quot;));\n      });\n    };\t\n  });\n  &#x2F;&#x2F; it();\n  after(function () {\n    &#x2F;&#x2F; 用完之后记得还原。否则影响其他case\n    fs.readFile = _readFile;\n  })\n});\n</code></pre><h4>\bMock库</h4>\n<p>Mock小模块：<a href=\"https://github.com/fent/node-muk\"><code>muk</code></a> ，略微优美的写法：</p>\n<pre class=\"prettyprint language- javascript\"><code>var fs = require(&#x27;fs&#x27;);\nvar muk = require(&#x27;muk&#x27;);\n\nbefore(function () {\n  muk(fs, &#x27;readFile&#x27;, function(path, encoding, callback) {\n    process.nextTick(function () {\n      callback(new Error(&quot;mock readFile error&quot;));\n    });\n  });\n});\n&#x2F;&#x2F; it();\nafter(function () {\n  muk.restore();\n});\n</code></pre><h2>测试私有方法</h2>\n<p>针对一些内部的方法，没有通过exports暴露出来，怎么测试它？</p>\n<pre class=\"prettyprint language- javascript\"><code>function _adding(num1, num2) {\n  return num1 + num2;\n}\n</code></pre><h4>通过rewire导出方法</h4>\n<p>模块：<a href=\"http://jhnns.github.com/rewire/\"><code>rewire</code></a></p>\n<pre class=\"prettyprint language-\"><code>it(&#x27;limit should return success&#x27;, function () {\n  var lib = rewire(&#x27;..&#x2F;lib&#x2F;index.js&#x27;);\n  var litmit = lib.__get__(&#x27;limit&#x27;);\n  litmit(10);\n});\n</code></pre><h2>测试Web应用</h2>\n<p>在开发Web项目的时候，要测试某一个API，如：<code>/user</code>，到底怎么编写测试用例呢？</p>\n<p>使用：<a href=\"https://github.com/visionmedia/supertest\"><code>supertest</code></a></p>\n<pre class=\"prettyprint language- javascript\"><code>var express = require(&quot;express&quot;);\nvar request = require(&quot;supertest&quot;);\nvar app = express();\n\n&#x2F;&#x2F; 定义路由\napp.get(&#x27;&#x2F;user&#x27;, function(req, res){\n  res.send(200, { name: &#x27;jerryc&#x27; });\n});\n\ndescribe(&#x27;GET &#x2F;user&#x27;, function(){\n  it(&#x27;respond with json&#x27;, function(done){\n    request(app)\n      .get(&#x27;&#x2F;user&#x27;)\n      .set(&#x27;Accept&#x27;, &#x27;application&#x2F;json&#x27;)\n      .expect(&#x27;Content-Type&#x27;, &#x2F;json&#x2F;)\n      .expect(200)\n      .end(function (err, res) {\n        if (err){\n          done(err);\n        }\n        res.body.name.should.be.eql(&#x27;jerryc&#x27;);\n        done();\n      })\n  });\n});\n</code></pre><h2>覆盖率</h2>\n<p>测试的时候，我们常常关心，是否所有代码都测试到了。</p>\n<p>这个指标就叫做<a href=\"http://en.wikipedia.org/wiki/Code_coverage\">&quot;代码覆盖率&quot;</a>（code coverage）。它有四个测量维度。</p>\n<blockquote>\n<ul>\n<li><strong>行覆盖率</strong>（line coverage）：是否每一行都执行了？</li>\n<li><strong>函数覆盖率</strong>（function coverage）：是否每个函数都调用了？</li>\n<li><strong>分支覆盖率</strong>（branch coverage）：是否每个if代码块都执行了？</li>\n<li><strong>语句覆盖率</strong>（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/gotwarlost/istanbul\">Istanbul</a> 是 JavaScript 程序的代码覆盖率工具。</p>\n<h4>安装</h4>\n<p><code>$ npm install -g istanbul</code></p>\n<h4>覆盖率测试</h4>\n<p>在编写过以上的测试用例之后，执行命令：</p>\n<p><code>istanbul cover _mocha</code></p>\n<p>就能得到覆盖率:</p>\n<pre class=\"prettyprint language- javascript\"><code>JerryC% istanbul cover _mocha                                                                                                                                                                \n\n\n  module\n    limit\n      ✓ limit should success\n    async\n      ✓ async\n    getContent\n      ✓ getContent\n    add\n      ✓ add\n\n  should\n    #Promise\n      ✓ should.reject\n      ✓ should fulfilled\n\n\n  6 passing (32ms)\n\n\n================== Coverage summary ======================\nStatements   : 100% ( 10&#x2F;10 )\nBranches     : 100% ( 2&#x2F;2 )\nFunctions    : 100% ( 5&#x2F;5 )\nLines        : 100% ( 10&#x2F;10 )\n==========================================================\n</code></pre><p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/eac87dbf-4e4b-426e-80ac-7c50e1b9a1cb.jpg\" alt=\"覆盖率html\"></p>\n<p>上面命令中，<code>istanbul cover</code> 命令后面跟的是 <code>_mocha</code> 命令，前面的下划线是不能省略的。</p>\n<p>因为，<a href=\"https://github.com/gotwarlost/istanbul/issues/44\">mocha 和 _mocha 是两个不同的命令</a>，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>\n<p>如果要向 mocha 传入参数，可以写成下面的样子。</p>\n<pre class=\"prettyprint language-\"><code>$ istanbul cover _mocha -- tests&#x2F;test.sqrt.js -R spec\n</code></pre><p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接<a href=\"http://www.clock.co.uk/blog/npm-module-code-coverage-in-2-simple-steps\">1</a>，<a href=\"http://www.vapidspace.com/coding/2014/10/29/code-coverage-metrics-with-mocha-and-istanbul/\">2</a>）。</p>\n<h2>使用Makefile串起项目</h2>\n<pre class=\"prettyprint language-\"><code>TESTS = test&#x2F;*.test.js\nREPORTER = spec\nTIMEOUT = 10000\nJSCOVERAGE = .&#x2F;node_modules&#x2F;jscover&#x2F;bin&#x2F;jscover\n\ntest:\n    @NODE_ENV=test .&#x2F;node_modules&#x2F;mocha&#x2F;bin&#x2F;mocha -R $(REPORTER) -t $(TIMEOUT) $(TESTS)\n\ntest-cov: lib-cov\n    @LIB_COV=1 $(MAKE) test REPORTER=dot\n    @LIB_COV=1 $(MAKE) test REPORTER=html-cov &gt; coverage.html\n\nlib-cov:\n    @rm -rf .&#x2F;lib-cov\n    @$(JSCOVERAGE) lib lib-cov\n\n.PHONY: test test-cov lib-cov\n\nmake test\nmake test-cov\n\n</code></pre><p>用项目自身的jscover和mocha，避免版本冲突和混乱</p>\n<h2>持续集成，Travis-cli</h2>\n<ul>\n<li><a href=\"https://travis-ci.org/\">Travis-ci</a>\n<ul>\n<li>绑定Github帐号</li>\n<li>在Github仓库的Admin打开Services hook</li>\n<li>打开Travis</li>\n<li>每次push将会hook触发执行<code>npm test</code>命令</li>\n</ul>\n</li>\n</ul>\n<p>注意：Travis会将未描述的项目当作Ruby项目。所以需要在根目录下加入<code>.travis.yml</code>文件。内容如下：</p>\n<pre class=\"prettyprint language- yaml\"><code>language: node_js\nnode_js:\n  - &quot;0.12&quot;\n</code></pre><p>Travis-cli还会对项目颁发标签，</p>\n<p><img src=\"https://camo.githubusercontent.com/f479d6cf4ac300093da5a90d70565cebf8c8ed40/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4a61636b736f6e5469616e2f626167706970652e706e67\" alt=\"/\">or <img src=\"https://camo.githubusercontent.com/08478cd5a732822aec47e6e60d5f823ef0898dec/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f54424544502f64617461766a732e706e67\" alt=\"/\"></p>\n<p>如果项目通过所有测试，就会build-passing，</p>\n<p>如果项目没有通过所有测试，就会build-failing</p>\n<h2>一些观点</h2>\n<p>实施单元测试的时候, 如果没有一份经过实践证明的详细规范, 很难掌握测试的 “度”, 范围太小施展不开, 太大又侵犯 “别人的” 地盘. 上帝的归上帝, 凯撒的归凯撒, 给单元测试念念紧箍咒不见得是件坏事, 反而更有利于发挥单元测试的威力, 为代码重构和提高代码质量提供动力.</p>\n<p>这份文档来自 Geotechnical, 是一份非常难得的经验准则. 你完全可以以这份准则作为模板, 结合所在团队的经验, 整理出一份内部单元测试准则.</p>\n<p><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">单元测试准则</a></p>\n<h2>彩蛋</h2>\n<p>最后，介绍一个库：<a href=\"https://github.com/Marak/Faker.js\"><code>faker</code></a></p>\n<p>他是一个能伪造用户数据的库，包括用户常包含的属性：个人信息、头像、地址等等。</p>\n<p>是一个开发初期，模拟用户数据的绝佳好库。</p>\n<p>支持Node.js和浏览器端。</p>\n<p><img src=\"http://xia-dev.b0.upaiyun.com/43075e5e-026f-4acb-a51f-a998cf1a6e11.jpg\" alt=\"生成用户\"></p>\n<h2>整理</h2>\n<h4>Nodejs的单元测试工具</h4>\n<ol>\n<li>测试框架 mocha</li>\n<li>断言库：should.js、expect.js、chai</li>\n<li>覆盖率：istanbul、jscover、blanket</li>\n<li>Mock库：muk</li>\n<li>测试私有方法：rewire</li>\n<li>Web测试：supertest</li>\n<li>持续集成：Travis-cli</li>\n</ol>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://github.com/JacksonTian/unittesting\">https://github.com/JacksonTian/unittesting</a></li>\n<li><a href></a><a href=\"http://html5ify.com/unittesting/slides/index.html\">http://html5ify.com/unittesting/slides/index.html</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/06/istanbul.html\">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>\n<li><a href=\"http://coolshell.cn/articles/8209.html\">http://coolshell.cn/articles/8209.html</a></li>\n<li><a href=\"http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests\">http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming\">http://www.codedata.com.tw/java/unit-test-the-way-changes-my-programming</a></li>\n<li><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D\">http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D</a></li>\n<li><a href=\"https://github.com/yangyubo/zh-unit-testing-guidelines\">https://github.com/yangyubo/zh-unit-testing-guidelines</a></li>\n<li><a href=\"https://github.com/visionmedia/superagent/blob/master/Makefile\">https://github.com/visionmedia/superagent/blob/master/Makefile</a></li>\n</ul>\n</div>",
      "title": "在Nodejs中贯彻单元测试",
      "last_reply_at": "2021-07-23T06:48:05.988Z",
      "good": true,
      "top": false,
      "reply_count": 70,
      "visit_count": 32524,
      "create_at": "2015-07-30T09:03:49.843Z",
      "author": {
        "loginname": "JerryC8080",
        "avatar_url": "https://avatars0.githubusercontent.com/u/6801672?v=4&s=120"
      }
    },
    {
      "id": "60fa2c5be3e671ac7a58f1d9",
      "author_id": "5cf4a00795fcc914aa265866",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>背景</h2>\n<p>项目中需要一份json配置文件，这份配置文件的某些字段是依据另外的一个typescrip文件<code>export</code>出来的字段，为了降低编码过程中造成的字段名出错的机率。</p>\n<p>因此，考虑开发一个插件用于：</p>\n<ul>\n<li>json文件中自动补全function name</li>\n<li>jaon文件到typescript文件的自定义跳转</li>\n<li>json文件中错误波浪线智能提示（当typescript文件没有export该字段时显示波浪线）</li>\n</ul>\n<p>插件效果：</p>\n<p><img src=\"https://itc.desaysv.com/dfs/wxapp-assets/other/hello.gif\" alt=\"IDE\"></p>\n<h2>实现</h2>\n<p>思路：定义两个插件变量（可根据实际情况自己在插件设置里面配置）</p>\n<ul>\n<li>fileName：用于识别文件名关键字 – 默认为<code>index</code></li>\n<li>filePath：以json文件为参照，index typescript文件的相对路径，用于获取ts文件 – 默认为<code>./src/index</code></li>\n<li>关键实现：使用<code>@babel/parser</code>、<code>@babel/traverse</code>将ts文件转化AST，这样才能获取到ts文件中export出来的function name</li>\n</ul>\n<p><a href=\"https://github.com/YonSunZhen/vscode-plugin-json-go-ts\">项目源码</a></p>\n<h3>自动补全</h3>\n<p>思路：</p>\n<ul>\n<li>获取ts文件中export出来的function列表</li>\n<li>监听VS Code中光标处输入的字符，当输入<code>index.</code>时，弹出自动补全面板，此时自动补全面板中的内容就是ts文件中export出来的所有function列表</li>\n</ul>\n<p>关键代码实现：</p>\n<pre class=\"prettyprint language-js\"><code>export function provideCompletionItems(document, position, token, context) {\n  const _filePath = getFilePath(document, filePath);\n  const _fnData = getFnFromTsFile(&#96;${_filePath}.ts&#96;);\n  const linePrefix = document.lineAt(position).text.substr(0, position.character);\n  if (!linePrefix.endsWith(&#96;&quot;${fileName}.&#96;)) {\n    return undefined;\n  }\n  let myitem = (text: string) =&gt; {\n    let item = new vscode.CompletionItem(text, vscode.CompletionItemKind.Function);\n    item.range = new vscode.Range(position, position);\n    return item;\n  };\n  return _fnData.map(_fnItem =&gt; myitem(_fnItem.fnName));\n}\n</code></pre><h3>跳转到定义</h3>\n<p>思路：</p>\n<ul>\n<li>获取ts文件中export出来的function列表，包括每个function对应的loc（即function在编辑器中所处的位置信息），<strong>这就是前面我们为什么要将ts文件转化为AST的重要原因</strong>，后面实现代码跳转需要用到这些位置信息</li>\n<li>获取光标处所在的function并跳转到对应ts文件中的对应位置</li>\n</ul>\n<p>关键代码实现：</p>\n<pre class=\"prettyprint language-js\"><code>export function provideDefinition(document: vscode.TextDocument, position: vscode.Position, token) {\n  const _filePath = getFilePath(document, filePath);\n  const _fnData = getFnFromTsFile(&#96;${_filePath}.ts&#96;);  \n  const _wordRangePosition = document.getWordRangeAtPosition(position);\n  const word = document.getText(_wordRangePosition); &#x2F;&#x2F; 获取当前光标输入字符\n  const _reg = new RegExp(&#96;&quot;${fileName}\\..*&quot;&#96;);  \n  if (_reg.test(word)) {\n    &#x2F;&#x2F; const _fnName = word.replace(&#x2F;&quot;index\\.|&quot;&#x2F;g, &#x27;&#x27;);\n    const _fnName = word.replace(new RegExp(&#96;&quot;${fileName}\\.|&quot;&#96;, &#x27;g&#x27;), &#x27;&#x27;);\n    if(_fnData.map(_fnItem =&gt; _fnItem.fnName).includes(_fnName)) {\n      const filePath = &#96;${_filePath}.ts&#96;;\n      for(const _fnItem of _fnData) {\n        if(_fnItem.fnName === _fnName) {\n          const tmpPath = &#96;file:&#x2F;&#x2F;&#x2F;${filePath}&#96;; &#x2F;&#x2F; TODO: 踩坑记录 必须 &#x2F;&#x2F;&#x2F;\n          if (fs.existsSync(filePath)) {\n            const _targetUri = vscode.Uri.parse(tmpPath); &#x2F;&#x2F; TODO: 踩坑记录 使用parse\n            const _targetPosition = new vscode.Position(_fnItem.loc.start.line, _fnItem.loc.start.column);\n            const _targetRange = new vscode.Range(_targetPosition, _targetPosition);\n            const _fileNameLen = (fileName as string).length || 0;\n             &#x2F;&#x2F; 当按住ctrl时，编辑器默认会将连在一块的字符都显示出来下划线 这时候如果想指定哪些字符需要显示下划线需要配置以下的originSelectionRange\n            const _orgSelectionStartPosition = new vscode.Position(_wordRangePosition.start.line, _wordRangePosition.start.character + _fileNameLen + 2);\n            const _orgSelectionEndPosition = new vscode.Position(_wordRangePosition.end.line, _wordRangePosition.end.character - 1);\n            const _originSelectionRange = new vscode.Range(_orgSelectionStartPosition, _orgSelectionEndPosition);\n            const _locationLink: vscode.LocationLink = {\n              originSelectionRange: _originSelectionRange,\n              targetUri: _targetUri,\n              targetRange: _targetRange\n            };\n            return [_locationLink];\n            &#x2F;&#x2F; return new vscode.Location(vscode.Uri.parse(tmpPath), new vscode.Position(_fnItem.loc.start.line, _fnItem.loc.start.column));\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre><h3>智能诊断&amp;提示</h3>\n<p>这个功能的主要对象是json文件，因此我们需要获取到json文件中所有的字段，包括每个字段所处的位置信息（为了后面显示波浪线），这时候我们可能会想到说，将json文件转化为AST，思路是正确的，但是前面说的<code>@babel/traverse</code>只能用来转化js或ts文件，并不支持json文件的转化</p>\n<p>幸好别人已经有写过类似的轮子了，<a href=\"https://www.npmjs.com/package/json-to-ast\">json-to-ast</a>出场，<code>json-to-ast</code>可以将json文件转化为AST，感谢开源。</p>\n<p>另外：在VS Code中智能诊断使用<code>createDiagnosticCollection</code>这个API来实现的，切记。</p>\n<p>关键代码实现：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 智能诊断 波浪线提示\nconst collection = vscode.languages.createDiagnosticCollection(&#x27;testFnName&#x27;);\nif (vscode.window.activeTextEditor) {\n  collection.clear();\n  updateDiagnostics(vscode.window.activeTextEditor.document, collection);\n}\n&#x2F;&#x2F; 使用onDidChangeTextDocument监听编辑文档事件\ncontext.subscriptions.push(vscode.workspace.onDidChangeTextDocument(editor =&gt; {\n  if (editor) {\n    collection.clear();\n    updateDiagnostics(editor.document, collection);\n  }\n}));\n</code></pre><pre class=\"prettyprint language-js\"><code>export function updateDiagnostics(document: vscode.TextDocument, collection: vscode.DiagnosticCollection): void {\n  const _text = document.getText();\n  const _jsonAst = jsonToAst(_text) as jsonToAst.ObjectNode;\n  const _errorText: JsonTextInfo[] = [];\n  const _filePath = getFilePath(document, filePath);\n  const _fnData = getFnFromTsFile(&#96;${_filePath}.ts&#96;);  \n  const recursiveJsonAst = (astArr: any[]) =&gt; {\n    astArr.forEach((jsonAstItem) =&gt; {\n      const _value = jsonAstItem?.value || jsonAstItem?.children;\n      if(_value.children) {\n        recursiveJsonAst(_value.children);\n      } else if(Array.isArray(_value)) {\n        recursiveJsonAst(_value);\n      } else {\n        const _textValue = _value.value;\n        const _reg = new RegExp(&#96;${fileName}\\..*&#96;, &#x27;g&#x27;);\n        if(_reg.test(_textValue)) {\n          const _fnVal = _textValue.replace(new RegExp(&#96;${fileName}\\.&#96;, &#x27;g&#x27;), &#x27;&#x27;);\n          if(!_fnData.map((_fnItem =&gt; _fnItem.fnName)).includes(_fnVal)) {\n            _errorText.push({\n              value: _fnVal,\n              loc: _value.loc\n            });\n          }\n        }\n      }  \n    });\n  };\n  recursiveJsonAst(_jsonAst.children);\n  const _diagCollection = [];\n  _errorText.forEach(_errTextItem =&gt; {\n    const _start = _errTextItem.loc.start;\n    const _end = _errTextItem.loc.end;\n    const _fileNameLen = (fileName as string).length || 0;\n    const _startPosition = new vscode.Position(_start.line - 1, _start.column + _fileNameLen + 1);\n    const _endPosition = new vscode.Position(_end.line - 1, _end.column - 2);\n    _diagCollection.push({\n      message: &#96;Function ${_errTextItem.value} does not exist&#96;,\n      range: new vscode.Range(_startPosition, _endPosition),\n      severity: vscode.DiagnosticSeverity.Error,\n    });\n  });\n  collection.set(document.uri, _diagCollection);\n}\n</code></pre><h2>一些踩坑</h2>\n<ol>\n<li>发布插件时执行<code>vsce publish</code>时报错<code>ERROR Failed request: (401)</code>，生成的personal access token权限弄错了，应该选<code>Full access</code></li>\n</ol>\n<p><img src=\"http://122.51.184.238/storage/files/1_5_%E6%9D%82%E7%83%A9/2_25_json-go-ts1.jpeg\" alt></p>\n<ol>\n<li>\n<p>发布插件时报错：<code>ERROR Make sure to edit the README.md file before you package or publish your extension</code> – 修改一下工程里面的<code>README.md</code>文件（原来的文件删除&amp;重写）</p>\n</li>\n<li>\n<p>使用<a href=\"https://marketplace.visualstudio.com/manage/createpublisher?managePageRedirect=true\">地址</a>创建publisher账号一直不成功 – 网络被限制了（科学上网真香）</p>\n</li>\n<li>\n<p>插件在本地开发环境下可以运行，发布到线上没有响应（也没有报错）</p>\n<p>经过排查，项目中使用了一些npm库，但是发布插件时使用了<code>tsc</code>来编译，这种情况下<code>node_modules</code>里面一些npm库的代码是没有被编译进去的。需要引入<code>webpack</code>来进行打包&amp;编译</p>\n</li>\n</ol>\n<h2>参考</h2>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/64584850/get-vscode-registercompletionitemprovider-to-work-in-a-json-file-with-a-word\">json文件中自动补全面板不弹出</a></li>\n<li><a href=\"https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html\">VS Code插件开发全攻略</a></li>\n<li><a href=\"https://code.visualstudio.com/api/working-with-extensions/publishing-extension\">VS Code Document</a></li>\n<li><a href=\"https://github.com/Microsoft/vscode-extension-samples/\">Some demo</a></li>\n</ul>\n</div>",
      "title": "json-go-ts VS Code插件开发",
      "last_reply_at": "2021-07-23T02:41:31.264Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 716,
      "create_at": "2021-07-23T02:41:31.264Z",
      "author": {
        "loginname": "YonSunZhen",
        "avatar_url": "https://avatars.githubusercontent.com/u/34334312?v=4&s=120"
      }
    },
    {
      "id": "60eea5dde3e671e6a858de34",
      "author_id": "5b0bef9657137f22415c46de",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>限流配置中，阈值其实是很难准确并恰当的设置的。\n我理解的配置原则：</p>\n<ol>\n<li>不能影响正常流量</li>\n<li>能起到限流作用，保护服务</li>\n</ol>\n<p>现状却是阈值真的很难配置，已经用了很多脑细胞，\n说下我的配置理解：</p>\n<ol>\n<li>服务会提供多个接口，多个接口在线上有多种请求组合，用户的使用方式无法精确预判，所以，没法以固定情景确定每个接口的阈值</li>\n<li>针对单个接口压测得到每个接口QPS上限，能做到不误杀的配置是，针对每个接口配置阈值，分别是接口QPS上限，但是这样大概率会不起作用，无法真的保护服务。</li>\n<li>按80%比例配置阈值，可能会误杀正常流量。\n各位有好的方案配置阈值嘛？</li>\n</ol>\n</div>",
      "title": "QPS限流如何设置阈值比较合理",
      "last_reply_at": "2021-07-22T03:29:40.603Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 2128,
      "create_at": "2021-07-14T08:52:45.174Z",
      "author": {
        "loginname": "LiuWeiMr",
        "avatar_url": "https://avatars.githubusercontent.com/u/17976666?v=4&s=120"
      }
    },
    {
      "id": "60f8c5e7e3e671375d58ef30",
      "author_id": "5c1ea9e976c4964062a1ca15",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>前言：开发Nodej.js Addon的方式经过不断地改进，已经逐步完善，至少我们不需要在升级Node.js版本的同时担心Addon用不了或者重新编译。目前Node.js提供的开发方式是napi。但是napi用起来非常冗余和麻烦，每一步都需要我们自己去控制，所以又有大佬封装了面向对象版本的api（node-addon-api），使用上方便了很多，本文分析一下node-addon-api的设计思想，但不会分析过多细节，因为我们理解了设计思想后，使用时去查阅文档或者看源码就可以。</strong></p>\n<p>我们首先看一下使用napi写一个hello world的例子。</p>\n<pre class=\"prettyprint language-c\"><code>#include &lt;assert.h&gt;\n#include &lt;node_api.h&gt;\n\nstatic napi_value Method(napi_env env, napi_callback_info info) {\n  napi_status status;\n  napi_value world;\n  status = napi_create_string_utf8(env, &quot;world&quot;, 5, &amp;world);\n  assert(status == napi_ok);\n  return world;\n}\n\n#define DECLARE_NAPI_METHOD(name, func)                                        \\\n  { name, 0, func, 0, 0, 0, napi_default, 0 }\n\nstatic napi_value Init(napi_env env, napi_value exports) {\n  napi_status status;\n  napi_property_descriptor desc = DECLARE_NAPI_METHOD(&quot;hello&quot;, Method);\n  status = napi_define_properties(env, exports, 1, &amp;desc);\n  assert(status == napi_ok);\n  return exports;\n}\n\nNAPI_MODULE(NODE_GYP_MODULE_NAME, Init)\n</code></pre><p>接着我们看一下node-addon-api版的写法。</p>\n<pre class=\"prettyprint language-c\"><code>#include &lt;napi.h&gt;\n\nNapi::String Method(const Napi::CallbackInfo&amp; info) {\n  Napi::Env env = info.Env();\n  return Napi::String::New(env, &quot;world&quot;);\n}\n\nNapi::Object Init(Napi::Env env, Napi::Object exports) {\n  exports.Set(Napi::String::New(env, &quot;hello&quot;),\n              Napi::Function::New(env, Method));\n  return exports;\n}\n\nNODE_API_MODULE(hello, Init)\n</code></pre><p>我们看到，代码简洁了很多，有点写js的感觉了。</p>\n<p>下面我们看看这些简洁背后的设计。我们从模块定义开始分析。</p>\n<pre class=\"prettyprint language-c\"><code>NODE_API_MODULE(hello, Init)\n</code></pre><p>NODE_API_MODULE是node-addon-api定义的宏。</p>\n<pre class=\"prettyprint language-c\"><code>#define NODE_API_MODULE(modname, regfunc)                                      \\\n  static napi_value __napi_##regfunc(napi_env env, napi_value exports) {       \\\n    return Napi::RegisterModule(env, exports, regfunc);                        \\\n  }                                                                            \\\n  NAPI_MODULE(modname, __napi_##regfunc)\n</code></pre><p>我们看到NODE_API_MODULE是对NAPI_MODULE的封装，NAPI_MODULE的分析可以参考之前napi原理相关的文章，这里就不具体分析。最后在加载addon的时候执行__napi_##regfunc函数。并传入napi_env env, napi_value exports参数。我们知道这是napi规范的参数。接着执行RegisterModule。</p>\n<pre class=\"prettyprint language-c\"><code>inline napi_value RegisterModule(napi_env env,\n                                 napi_value exports,\n                                 ModuleRegisterCallback registerCallback) {\n  &#x2F;&#x2F; details::WrapCallback里会执行lamda函数并返回lamda的返回值                      \n  return details::WrapCallback([&amp;] {\n    return napi_value(registerCallback(Napi::Env(env),\n                                       Napi::Object(env, exports)));\n  });\n}\n</code></pre><p>RegisterModule里最终会执行registerCallback。我们看一下registerCallback变量的类型ModuleRegisterCallback的定义。</p>\n<pre class=\"prettyprint language-c\"><code>typedef Object (*ModuleRegisterCallback)(Env env, Object exports);\n</code></pre><p>所以registerCallback的参数是Env和Object对象。这两个类不是Node.js也不是V8定义的，而是node-addon-api。我们一会再分析，我们先知道他是两个对象就好。这里registerCallback的值是我们定义的Init函数。</p>\n<pre class=\"prettyprint language-c\"><code>Napi::Object Init(Napi::Env env, Napi::Object exports) {\n  exports.Set(Napi::String::New(env, &quot;hello&quot;),\n              Napi::Function::New(env, Method));\n  return exports;\n}\n</code></pre><p>通过Set方法给exports定义属性，我们在js就可以访问对应的属性了。最后返回exports，exports是Object类型。但根据napi的接口定义。返回的类型应该是napi_value。我们看看node-addon-api是怎么做的。我们回到RegisterModule函数。</p>\n<pre class=\"prettyprint language-c\"><code>return napi_value(registerCallback(Napi::Env(env),  Napi::Object(env, exports)));\n</code></pre><p>我们看到registerCallback执行后的返回值会被转成napi_value类型。那么Object类型是怎么自动转成napi_value类型的呢？我们一会分析。了解了node-addon-api的使用方式后，我们开始具体分析其中的设计。</p>\n<p>我们先看看Env的设计。</p>\n<pre class=\"prettyprint language-c\"><code>class Env {\n  public:\n    Env(napi_env env);\n    operator napi_env() const;\n\n  private:\n    napi_env _env;\n};\n\ninline Env::Env(napi_env env) : _env(env) {\n}\n\n&#x2F;&#x2F; 类型重载\ninline Env::operator napi_env() const {\n  return _env;\n}\n</code></pre><p>我们只看核心的设计，忽略一些无关重要的细节。我们看到Env的设计很简单，就是对napi的napi_env的封装。接着我们看类型的设计。</p>\n<pre class=\"prettyprint language-c\"><code>class Value {\n  public:\n    Value();     \n    Value(napi_env env,  napi_value value);  \n    operator napi_value() const;\n    Napi::Env Env() const;\n\n  protected:\n    napi_env _env;\n    napi_value _value;\n};\n</code></pre><p>Value是node-addon-api的类型基类，类似V8里的设计。我们看到Value里面只有两个字段，env和_value。env就是我们刚才提到的Env。_value就是对napi类型的封装。Value类只是抽象的封装，不涉及到具体的逻辑。下面我们以自定义的Init函数为例，开始分析具体的逻辑。</p>\n<pre class=\"prettyprint language-c\"><code>Napi::Object Init(Napi::Env env, Napi::Object exports) {\n  exports.Set(Napi::String::New(env, &quot;hello&quot;), Napi::Function::New(env, Method));\n  return exports;\n}\n</code></pre><p>我们先看看String::New的实现。</p>\n<pre class=\"prettyprint language-c\"><code>class Name : public Value {\n  public:\n    Name();                     \n    Name(napi_env env, napi_value value); \n};\n  \nclass String : public Name {\n  public:\n   static String New(napi_env env, const char* value);\n};\n\ninline String String::New(napi_env env, const char* val) {\n  napi_value value;\n  napi_status status = napi_create_string_utf8(env, val, std::strlen(val), &amp;value);\n  NAPI_THROW_IF_FAILED(env, status, String());\n  return String(env, value);\n}\n</code></pre><p>我们看到New的实现很简单，主要是对napi的封装。但有些细节还是需要注意的。\n1 我们看到exports.Set函数的第一个参数是Env类型，但是New函数的第一个参数类型是napi_env，看起来不兼容。这个是如何自动转换的呢？因为Env类对napi_env类型进行了重载。</p>\n<pre class=\"prettyprint language-c\"><code>inline Env::operator napi_env() const {\n  return _env;\n}\n</code></pre><p>我们看到当需要napi_env类型的时候，Env会返回_env，_env就是napi_env类型。\n2 通过napi接口创建了值之后，最后返回的是一个String类型。我们看看String构造函数。</p>\n<pre class=\"prettyprint language-c\"><code>inline String::String(napi_env env, napi_value value) : Name(env, value) {}\n\ninline Name::Name(napi_env env, napi_value value) : Value(env, value) {}\n</code></pre><p>最后调用Value构造函数保存了napi返回的值。并且给调用方返回了一个String对象。我们看看exports.Set(Napi::String::New(env, “hello”), Napi::Function::New(env, Method))的时候是如何使用这个String对象的。exports是一个Object。Object和String的实现是类似的，他们都是继承Value类，在内部封装了napi_env和napi_value变量。所以我们看看Object::Set的实现。</p>\n<pre class=\"prettyprint language-c\"><code>template &lt;typename ValueType&gt;\ninline bool Object::Set(napi_value key, const ValueType&amp; value) {\n  napi_status status = napi_set_property(_env, _value, key, Value::From(_env, value));\n  NAPI_THROW_IF_FAILED(_env, status, false);\n  return true;\n}\n</code></pre><p>_value的值是Object封装的napi_value对象，也就是一个V8 Object对象。然后通过napi_set_property设置对象的属性和值。同样我们发现Set函数的实参是String对象，但是型参是napi_value类型。这个和Env的自动转换是类似的，String继承了Value，而Value重载了类型napi_value。</p>\n<pre class=\"prettyprint language-c\"><code>inline Value::operator napi_value() const {\n  return _value;\n}\n</code></pre><p>即返回了封装的napi_value变量。我们通过Set设置了一个属性hello，值是一个函数。</p>\n<pre class=\"prettyprint language-c\"><code>Napi::String Method(const Napi::CallbackInfo&amp; info) {\n  Napi::Env env = info.Env();\n  return Napi::String::New(env, &quot;world&quot;);\n}\n</code></pre><p>当我们在js层调用hello的时候，不会执行这个函数，而是先执行node-addon-api的代码，node-addon-api对napi的变量进行封装后，才会调用Method。所以我们看到Method的入参类型和napi的是不一样的。最后Method执行完返回的时候，同样是先回到node-addon-api。node-addon-api把Method的返回值（String对象）转成napi的格式后（napi_value）再返回到napi（这里比较复杂，目前还没有深入分析）。</p>\n<p>至此我们看到了node-addon-api设计的基本思想如图所示。\n<img src=\"https://img-blog.csdnimg.cn/20210714202405984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70\" alt>\n大致的思想就是node-addon-api为我们封装了一层，当napi调用我们定义的内容时，会先经过node-addon-api。node-addon-api封装napi的入参后再调用我们自定义的内容。同样，我们返回内容给napi时，也会经过node-addon-api的封装再回到napi。比如我们在addon里创建一个数字时，\t我们会执行Number New(napi_env env, double value);New会调用napi的napi_create_double创建一个napi_value变量。接着把napi_value的值封装到Number，最后返回一个Number给我们，后续我们调用Number的其他方法时，node-addon-api会从Number对象中拿到保存napi_value的值，再调用napi的api。这样我们只需要面对node-addon-api提供的接口而不需要理解napi。另外node-addon-api还做了一些运算符重载使得我们写代码更容易。比如对Object []的重载。</p>\n<pre class=\"prettyprint language-c\"><code> Value operator []( const char* utf8name) const;\n</code></pre><p>我们看看实现。</p>\n<pre class=\"prettyprint language-c\"><code>inline Value Object::operator [](const char* utf8name) const {\n  return Get(utf8name);\n}\n\ninline Value Object::Get(const char* utf8name) const {\n  napi_value result;\n  napi_status status = napi_get_named_property(_env, _value, utf8name, &amp;result);\n  NAPI_THROW_IF_FAILED(_env, status, Value());\n  return Value(_env, result);\n}\n</code></pre><p>这样我们就可以通过obj[‘name’]这种方式访问对象了。否则我们还需要像下面的方式访问。</p>\n<pre class=\"prettyprint language-c\"><code>napi_value value;\nnapi_status status = napi_get_named_property(_env, _value, key, &amp;value);\n</code></pre><p>如果大量这样的代码将会非常麻烦和低效。另外node-addon-api对类型进行了大量的重载，使得变量的类型转换得以自动进行不需要强制转换来转换去。比如我们可以直接执行以下代码。</p>\n<pre class=\"prettyprint language-c\"><code>int32_t num = Number对象;\n</code></pre><p>因为Number对int32_t进行了重载。</p>\n<pre class=\"prettyprint language-c\"><code>inline Number::operator int32_t() const {\n  return Int32Value();\n}\n\ninline int32_t Number::Int32Value() const {\n  int32_t result;\n  napi_status status = napi_get_value_int32(_env, _value, &amp;result);\n  NAPI_THROW_IF_FAILED(_env, status, 0);\n  return result;\n}\n</code></pre><p><strong>后记：本文大致分析了node-addon-api的实现原理和思想，实现的代码将近万行，虽然有很多类似的逻辑，但是也有些比较复杂的封装，有兴趣的同学可自行阅读。\n.</strong></p>\n</div>",
      "title": "node-addon-api的设计和实现",
      "last_reply_at": "2021-07-22T01:12:07.416Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 814,
      "create_at": "2021-07-22T01:12:07.416Z",
      "author": {
        "loginname": "theanarkh",
        "avatar_url": "https://avatars.githubusercontent.com/u/21155906?v=4&s=120"
      }
    },
    {
      "id": "60bc9b8b248d045d934ab22c",
      "author_id": "5ab852d6320bb09d69e231f1",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>请教一个困扰我好久的基础问题,如何判断一个方法是不是异步的?\n比如,我自己写一个自定义函数\n如果是下面这样的,肯定得用await包装一下才能顺序执行:</p>\n<p><img src=\"//static.cnodejs.org/FpLvBsnTGq0DsrJRF7moPZSLb9iW\" alt=\"12.png\"></p>\n<p>如果是下面这样的,那方法就不用加async了,直接写就能顺序执行:</p>\n<p><img src=\"//static.cnodejs.org/Fl4wunh11_3q4ejIrcOfys_gcKwl\" alt=\"13.png\"></p>\n<p>上面例子举的有点极端,但是有的方法在调用的时候真的不知道是不是异步的?如何知道我 自己写的函数 到底用不用async封装一下?或者说如何知道一个方法是不是异步的呢?</p>\n</div>",
      "title": "如何判断一个方法是不是异步的?",
      "last_reply_at": "2021-07-22T00:40:49.024Z",
      "good": false,
      "top": false,
      "reply_count": 16,
      "visit_count": 2496,
      "create_at": "2021-06-06T09:55:23.653Z",
      "author": {
        "loginname": "iori2882",
        "avatar_url": "https://avatars.githubusercontent.com/u/1480587?v=4&s=120"
      }
    },
    {
      "id": "60ed05cae3e671154458d802",
      "author_id": "5ef732e113f8b244e57cba0a",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>请问用nodejs 做saas架构的web系统怎么做数据隔离，typeorm是否有好的方案做租户数据隔离操作，或者有没有其他的好的实践方案。不想每个操作数据库的地方人工判断，想要一个可以自动拦截sql自动处理识别租户然后再和数据库交互的方法。</p>\n</div>",
      "title": "请问用nodejs 做saas架构的web系统怎么做数据隔离",
      "last_reply_at": "2021-07-21T13:44:51.147Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 2335,
      "create_at": "2021-07-13T03:17:30.184Z",
      "author": {
        "loginname": "tuohuang",
        "avatar_url": "https://avatars.githubusercontent.com/u/14804820?v=4&s=120"
      }
    }
  ]
}

export { resp }
